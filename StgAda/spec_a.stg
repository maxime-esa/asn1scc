group a_spec;

rtlModuleName() ::= "adaasn1rtl"


indentation(sStatement) ::=<<
    <sStatement>
>>


PrintSpecificationFile(sFileNameWithNoExtUpperCase, sPackageName, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrototypes, arrsUtilityDefines, bHasEncodings, bXer) ::= <<
pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "no entities of ""Interfaces"" are referenced");
with Interfaces;
pragma Warnings (On, "no entities of ""Interfaces"" are referenced");

pragma Warnings (Off, "use clause for package ""Interfaces"" has no effect");
use Interfaces;
pragma Warnings (On, "use clause for package ""Interfaces"" has no effect");

with <rtlModuleName()>;
<if(bHasEncodings)>
pragma Warnings (Off, "unit ""<rtlModuleName()>.encoding"" is not referenced");
with <rtlModuleName()>.encoding;
pragma Warnings (On, "unit ""<rtlModuleName()>.encoding"" is not referenced");

<endif>
<if(bXer)>
with <rtlModuleName()>.encoding.xer;

<endif>


pragma Warnings (Off, "unit ""System"" is not referenced");
with System;
pragma Warnings (On, "unit ""System"" is not referenced");

pragma Warnings (Off, "use clause for package ""<rtlModuleName()>"" has no effect");
use <rtlModuleName()>;
pragma Warnings (On, "use clause for package ""<rtlModuleName()>"" has no effect");

pragma Warnings (Off, "use clause for type");
pragma Warnings (Off, "is already use-visible through package use clause at line");
use type <rtlModuleName()>.OctetBuffer;
use type <rtlModuleName()>.BitArray;
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;
pragma Warnings (On, "use clause for type");
pragma Warnings (On, "is already use-visible through package use clause at line");

<arrsIncludedModules:{inc|
pragma Warnings (Off, "no entities of ""<inc>"" are referenced");
pragma Warnings (Off, "use clause for package ""<inc>"" has no effect");
with <inc>; use <inc>;
pragma Warnings (On, "no entities of ""<inc>"" are referenced");
pragma Warnings (On, "use clause for package ""<inc>"" has no effect");
}; separator="\n">


package <sPackageName> with SPARK_Mode
is


<arrsTypeAssignments:{tas|<tas>}; separator="\n">
pragma Warnings (Off, "there are no others");
<arrsValueAssignments:{vas|<vas>}; separator="\n">
pragma Warnings (On, "there are no others");
private
   --# hide <sPackageName>;


end <sPackageName>;
>>





Define_TAS(sTypeDefinition, arrsProcs) ::= <<
<sTypeDefinition>

<arrsProcs; separator="\n\n">
>>


PrintValueAssignment(sVasName, sTypeDecl, sValue) ::= <<
<sVasName> : constant <sTypeDecl>:= <sValue>;
>>



ExtraParams(extraPrms) /*nogen*/ ::= "<if(extraPrms)>, <extraPrms; separator=\", \"><endif>"

/* arrsEncDecInOutPrmsNames */





Declare_IntegerNoRTL() ::="Asn1Int"
Declare_PosIntegerNoRTL() ::="Asn1UInt"

Declare_Integer() ::="<rtlModuleName()>.Asn1Int"
Declare_PosInteger() ::="<rtlModuleName()>.Asn1UInt"

Declare_Int8() ::="Interfaces.Integer_8"
Declare_UInt8() ::="Interfaces.Unsigned_8"
Declare_Int16() ::="Interfaces.Integer_16"
Declare_UInt16() ::="Interfaces.Unsigned_16"
Declare_Int32() ::="Interfaces.Integer_32"
Declare_UInt32() ::="Interfaces.Unsigned_32"
Declare_Int64() ::="Interfaces.Integer_64"
Declare_UInt64() ::="Interfaces.Unsigned_64"

Declare_Real32() ::= "Standard.Float"
Declare_Real64() ::= "Standard.Long_Float"


Declare_Boolean() ::= "<rtlModuleName()>.Asn1Boolean"
Declare_Real() ::= "<rtlModuleName()>.Asn1Real"
Declare_Null() ::= "<rtlModuleName()>.Asn1NullType"

Declare_BooleanNoRTL() ::= "Asn1Boolean"
Declare_RealNoRTL() ::= "Asn1Real"

Declare_ObjectIdentifierNoRTL() ::= "Asn1ObjectIdentifier"
Declare_ObjectIdentifier() ::= "<rtlModuleName()>.Asn1ObjectIdentifier"

Declare_NullNoRTL() ::= "Asn1NullType"

Declare_Asn1LocalTime                 	()::= "<rtlModuleName()>.Asn1LocalTime"
Declare_Asn1UtcTime                   	()::= "<rtlModuleName()>.Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZone     	()::= "<rtlModuleName()>.Asn1TimeWithTimeZone"
Declare_Asn1Date                      	()::= "<rtlModuleName()>.Asn1Date"
Declare_Asn1Date_LocalTime            	()::= "<rtlModuleName()>.Asn1DateLocalTime"
Declare_Asn1Date_UtcTime              	()::= "<rtlModuleName()>.Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZone	()::= "<rtlModuleName()>.Asn1DateTimeWithTimeZone"

Declare_Asn1LocalTimeNoRTL                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTimeNoRTL                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZoneNoRTL     	()::= "Asn1TimeWithTimeZone"
Declare_Asn1DateNoRTL                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTimeNoRTL            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTimeNoRTL              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZoneNoRTL	()::= "Asn1DateTimeWithTimeZone"





Define_SubType_int_range(soParentTypePackage, sParentType, noMin, noMax) ::= <<
range <if(noMin)><noMin><else><if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>'First<endif> .. <if(noMax)><noMax><else><if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>'Last<endif>
>>


Define_SubType(sTypeDefinitionName, soParentTypePackage, sParentType, soNewRange, soExtraDefs, arrsAnnots) ::= <<
subtype <sTypeDefinitionName> is <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType><if(soNewRange)> <soNewRange><endif>;
<soExtraDefs>
>>

/******************************************************************************************************************************/
/***********************************       NEW TYPE DEFINITIONS    ************************************************************/
/******************************************************************************************************************************/

define_subtype(thisType, parentType, soParentTypePackage) ::= /*nogen*/<<
subtype <thisType> is <if(soParentTypePackage)><soParentTypePackage>.<endif><parentType>;
>>

/***********************************       ENUMERATED    ************************************************************/


Define_new_enumerated_item(td/*:FE_EnumeratedTypeDefinition*/, sName, nValue) ::= "<sName> => <nValue>"

Define_new_enumerated_item_macro(td/*:FE_EnumeratedTypeDefinition*/, sAsn1Name, sCName) ::= ""

Define_new_enumerated(td/*:FE_EnumeratedTypeDefinition*/, arrsEnumNames, arrsEnumNamesAndValues, nIndexMax, arrsResolvingMacros) ::= <<
subtype <td.index_range> is Integer range 0..<nIndexMax>;
type <td.typeName> is (<arrsEnumNames; separator=", ">) with Size => adaasn1rtl.Enumerated_Size;
for <td.typeName> use
    (<arrsEnumNamesAndValues; separator=", ">);
>>

Define_subType_enumerated(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, soParentTypePackage) ::= <<
<define_subtype(thisType=td.typeName, parentType=prTd.typeName, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.index_range, parentType=prTd.index_range, soParentTypePackage=soParentTypePackage)>
>>

Define_new_enumerated_private(td/*:FE_EnumeratedTypeDefinition*/, arrsValidEnumNames, arrsEnumNames) ::= <<
>>

Define_subType_enumerated_private(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, arrsValidEnumNames, arrsEnumNames) ::= <<
>>


/***********************************       STRING    ************************************************************/

Define_new_ia5string(td/*:FE_StringTypeDefinition*/, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
subtype <td.encoding_range> is Integer range <nMin>..<nMax>;
subtype <td.index> is Integer range 1..<nCMax>;
subtype <td.typeName> is String(<td.index>);
<if(arrnAlphaChars)>
subtype <td.alpha_index> is Integer range 1..<arrnAlphaChars.Length>;
subtype <td.alpha> is String(<td.alpha_index>);
<td.alpha_set> : constant <td.alpha> := <td.alpha>'(<arrnAlphaChars:{c|<i>=>Character'Val(<c>)}; wrap, anchor,  separator=", ">);

<endif>
>>


Define_subType_ia5string(td/*:FE_StringTypeDefinition*/, prTd/*:FE_StringTypeDefinition*/, soParentTypePackage) ::= <<
subtype <td.typeName> is <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.typeName>
subtype <td.encoding_range> is <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.encoding_range>;
subtype <td.index> is <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.index>;
<if(arrnAlphaChars)>
subtype <td.alpha_index> is <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.alpha_index>;
subtype <td.alpha> <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.alpha>;
<td.alpha_set> : constant := <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.alpha_set>;

<endif>
>>


/***********************************       OCTET STRING    ************************************************************/
Define_new_octet_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, arrsInvariants) ::= <<
subtype <td.index> is Integer range 1..<nMax>;
subtype <td.array> is <rtlModuleName()>.OctetBuffer(<td.index>);
<if(!bFixedSize)>subtype <td.length_index> is Integer range <nMin>..<nMax>;<endif>
type <td.typeName> is  record
<if(!bFixedSize)>    Length : <td.length_index>;<endif>
    Data  : <td.array>;
end record;
>>

Define_subType_octet_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
<define_subtype(thisType=td.typeName, parentType=prTd.typeName, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.index, parentType=prTd.index, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.array, parentType=prTd.array, soParentTypePackage=soParentTypePackage)>
<if(!bFixedSize)>
<define_subtype(thisType=td.length_index, parentType=prTd.length_index, soParentTypePackage=soParentTypePackage)>

<endif>
>>


/***********************************       BIT STRING    ************************************************************/
Define_new_bit_string_named_bit(td/*:FE_SizeableTypeDefinition*/, sTargetLangBitName, sHexValue, sComment) ::= <<
<td.typeName>_<sTargetLangBitName> : constant <rtlModuleName()>.Asn1UInt:= 16#<sHexValue>#;  --<sComment>
>>

Define_new_bit_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, nMaxOctets, arrsNamedBits, arrsInvariants) ::= <<
<arrsNamedBits:{it|<it>}; separator="\n">

subtype <td.index> is Integer range 1..<nMax>;
subtype <td.array> is <rtlModuleName()>.BitArray(<td.index>);
<if(!bFixedSize)>subtype <td.length_index> is Integer range <nMin>..<nMax>;<endif>
type <td.typeName> is  record
<if(!bFixedSize)>    Length : <td.length_index>;<endif>
    Data  : <td.array>;
end record;
>>

Define_subType_bit_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
<define_subtype(thisType=td.typeName, parentType=prTd.typeName, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.index, parentType=prTd.index, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.array, parentType=prTd.array, soParentTypePackage=soParentTypePackage)>
<if(!bFixedSize)>
<define_subtype(thisType=td.length_index, parentType=prTd.length_index, soParentTypePackage=soParentTypePackage)>

<endif>
>>


/***********************************       SEQUENCE OF    ************************************************************/

Define_new_sequence_of(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, sChildType, soChildDefinition, arrsSizeClassDefinition, arrsSizeObjDefinition, arrsInvariants) ::= <<
-- <td.typeName> --------------------------------------------

<soChildDefinition>

subtype <td.index> is Integer range 1..<nMax>;
type <td.array> is array (<td.index>) of <sChildType>;
<if(!bFixedSize)>subtype <td.length_index> is Integer range <nMin>..<nMax>;<endif>
type <td.typeName> is  record
<if(!bFixedSize)>    Length : <td.length_index>;<endif>
    Data  : <td.array>;
end record;
>>

Define_subType_sequence_of(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize, soChildDefinition) ::= <<
<soChildDefinition>

<define_subtype(thisType=td.typeName, parentType=prTd.typeName, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.index, parentType=prTd.index, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.array, parentType=prTd.array, soParentTypePackage=soParentTypePackage)>
<if(!bFixedSize)>
<define_subtype(thisType=td.length_index, parentType=prTd.length_index, soParentTypePackage=soParentTypePackage)>

<endif>
>>

/***********************************       SEQUENCE    ************************************************************/

Define_new_sequence_child_bit(sName) ::= "<sName>:<rtlModuleName()>.bit;"

Define_new_sequence_child(sName, sType, bIsOptional) ::= "<sName> : <sType>;"
Define_new_sequence_save_pos_child(td/*:FE_SequenceTypeDefinition*/, sName, nMaxBytesInACN) ::= "<sName> : <rtlModuleName()>.encoding.BitstreamPtr;"

Define_new_sequence(td/*:FE_SequenceTypeDefinition*/, arrsChildren, arrsOptionalChildren, arrsChildrenDefinitions, arrsNullFieldsSavePos, arrsSizeDefinition, arrsInvariants) ::= <<
-- <td.typeName> --------------------------------------------
<arrsChildrenDefinitions; separator= "\n">

<if(arrsChildren)>
<if (arrsOptionalChildren)>
type <td.exist> is record
    <arrsOptionalChildren; separator="\n">
end record with Pack;

for <td.exist>'Size use ((<length(arrsOptionalChildren)> - 1) / System.Word_Size + 1) * System.Word_Size;

<endif>
<if (arrsNullFieldsSavePos)>
type <td.extension_function_positions> is record
    <arrsNullFieldsSavePos; separator="\n">
end record;

<endif>
type <td.typeName> is record
    <arrsChildren; separator="\n">
    <if (arrsOptionalChildren)>

    Exist : <td.exist>;

    <endif>
end record;

<else>
type <td.typeName> is record
    null;
end record;

<endif>
>>

Define_subType_sequence(td/*:FE_SequenceTypeDefinition*/, prTd/*:FE_SequenceTypeDefinition*/, soParentTypePackage, arrsOptionalChildren, arrsExtraDefs) ::= <<
<define_subtype(thisType=td.typeName, parentType=prTd.typeName, soParentTypePackage=soParentTypePackage)>
<if(arrsOptionalChildren)>
<define_subtype(thisType=td.exist, parentType=prTd.exist, soParentTypePackage=soParentTypePackage)>

<endif>
<if (arrsNullFieldsSavePos)>
<define_subtype(thisType=td.extension_function_positions, parentType=prTd.extension_function_positions, soParentTypePackage=soParentTypePackage)>

<endif>

>>


/***********************************       CHOICE    ************************************************************/

Define_new_choice_child(sName, sType, sPresent) ::=<<
when <sPresent> =>
        <sName>: <sType>;
>>

Define_new_choice(td/*:FE_ChoiceTypeDefinition*/, sChoiceIDForNone, sFirstChildNamePresent, arrsChildren, arrsPresent, arrsCombined, nIndexMax, arrsChildrenDefinitions, arrsSizeDefinition) ::= <<
-- <td.typeName> --------------------------------------------
<arrsChildrenDefinitions; separator= "\n">

subtype <td.index_range> is Integer range 0..<nIndexMax>;

type <td.selection> is (<arrsPresent; separator=", ">);
for <td.selection> use
    (<arrsPresent:{c|<c> => <i>}; separator=", ">);
for <td.selection>'Size use 32;

type <td.typeName>(kind : <td.selection>:= <sFirstChildNamePresent>) is
record
    case kind is
    <arrsChildren; separator="\n">
    end case;
end record;

for <td.typeName> use
record
    kind at 0 range 0..31;
end record;
>>

Define_subType_choice(td/*:FE_ChoiceTypeDefinition*/, prTd/*:FE_ChoiceTypeDefinition*/, soParentTypePackage) ::= <<
<define_subtype(thisType=td.typeName, parentType=prTd.typeName, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.index_range, parentType=prTd.index_range, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.selection, parentType=prTd.selection, soParentTypePackage=soParentTypePackage)>
>>
