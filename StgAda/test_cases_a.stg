/*
* Copyright (c) 2008-2012 Semantix and (c) 2012-2015 Neuropublic
*
* This file is part of the ASN1SCC tool.
*
* Licensed under the terms of GNU General Public Licence as published by
* the Free Software Foundation.
*
*  For more informations see License.txt file
*/

group spark_automatic_test_cases;

rtlModuleName() ::= "adaasn1rtl"


PrintAutomaticTestCasesSpecFile(sModNameUpperCase, sModName, arrsIncludedModules, arrsTestFunctions) ::= <<
pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "unit ""<rtlModuleName()>"" is not referenced");
with <rtlModuleName()>;
pragma Warnings (Off, "unit ""<rtlModuleName()>"" is not referenced");
--with <sModName>;

<arrsIncludedModules:{inc| 
pragma Warnings (Off, "no entities of ""<inc>"" are referenced");
pragma Warnings (Off, "unit ""<inc>"" is not referenced");
with <inc>;
pragma Warnings (On, "no entities of ""<inc>"" are referenced");
pragma Warnings (On, "unit ""<inc>"" is not referenced");
}; separator="\n">

<if(arrsIncludedModules)>

<endif>
package <sModName>_auto_tcs
is

<arrsTestFunctions; separator="\n\n">

end <sModName>_auto_tcs;
>>
                
PrintCodec_spec(sFuncName, sModName, sTasName, sStar, sVal) ::= <<
function <sFuncName>(<sVal>:<sModName>.<sTasName>; Filename : in String) return <rtlModuleName()>.TEST_CASE_RESULT;
>>


PrintAutomaticTestCasesBodyFile(sModName, sTetscaseSpecFileName, arrsIncludedModules, arrsTasNames, arrsTestFunctions, bXer) ::= <<
pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
with Interfaces;
with adaasn1rtl.encoding.test_cases_aux;
<if(bXer)>
with adaasn1rtl.encoding.xer;

<endif>

pragma Warnings (Off, "use clause for type");
use type Interfaces.Unsigned_8;
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;
use type <rtlModuleName()>.Asn1ObjectIdentifier;
pragma Warnings (On, "use clause for type");

<arrsIncludedModules:{inc| 
pragma Warnings (Off, "no entities of ""<inc>"" are referenced");
pragma Warnings (Off, "use clause for package ""<inc>"" has no effect");
pragma Warnings (Off, "unit ""<inc>"" is not referenced");
with <inc>; USE <inc>;
pragma Warnings (On, "no entities of ""<inc>"" are referenced");
pragma Warnings (On, "use clause for package ""<inc>"" has no effect");
pragma Warnings (On, "unit ""<inc>"" is not referenced");
}; separator="\n">
<arrsTasNames: {tasName|use type <tasName>;}; separator="\n">
package body <sModName>_auto_tcs 
is 

<arrsTestFunctions; separator="\n\n">

end <sModName>_auto_tcs;
>>







Codec_Encode(sModName, sFuncName, sVal) ::= <<
--  Encode value
<sModName>.<sFuncName>(<sVal>, stream, result);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_ENCODE, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_Decode(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
--  Decode value
--  at this point stream contains the <sEnc> data
stream.Current_Bit_Pos :=0;
<sModName>.<sFuncName>(decodedPDU, stream, result);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_Decode_XER(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
--  Decode value
--  at this point stream contains the <sEnc> data
stream.CurrentByte :=1;
<sModName>.<sFuncName>(decodedPDU, stream, result);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
>>



Codec_validate_output(sModName, sFuncName, sAmber) ::= <<
--  validate decoded data
result := <sModName>.<sFuncName>(decodedPDU);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_VALIDATE_DECODED, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_compare_input_with_output(sModName, sFuncName, sVal, sAmber) ::= <<
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_EQUAL, Success => <sModName>.<sFuncName>(<sVal>, decodedPDU), ErrorCode => result.ErrorCode);
>>

Codec_write_bitstreamToFile() ::= <<
adaasn1rtl.encoding.test_cases_aux.Write_BitStream_To_File(stream, Filename & ".dat");
>>

Codec_write_CharstreamToFile() ::= <<
adaasn1rtl.encoding.xer.Write_CharStream_To_File(stream, Filename & ".dat");
>>

JoinItems(sPart, soNestedPart) ::= <<
<sPart>
<if(soNestedPart)>
if result.Success  then
    <soNestedPart>
end if;

<endif>
>>


Codec_declare_EncInDecOut_variable(sPrmName, sType, sPrmValue) ::= <<
enc_<sPrmName> : constant <sType> := <sPrmValue>;
dec_<sPrmName> : <sType>;
>>

Codec_declare_DecIn_variable(sPrmName, sType) ::= "dec_<sPrmName> : <sType>;"

        



PrintCodec_body(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements, sCodecClass) ::= <<
function <sFuncName>(<sVal>:<sModName>.<sTasName>; Filename : in String) return <rtlModuleName()>.TEST_CASE_RESULT
is
    decodedPDU  : <sModName>.<sTasName>;
    stream      : adaasn1rtl.encoding.Bitstream := adaasn1rtl.encoding.BitStream_init((if <sModName>.<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING = 0 then 1 else <sModName>.<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING));
    result      : <rtlModuleName()>.ASN1_RESULT;
    ret         : <rtlModuleName()>.TEST_CASE_RESULT;
begin
    <sNestedStatements>
    return ret;
end <sFuncName>;
>>

PrintCodec_body_XER(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
function <sFuncName>(<sVal>:<sModName>.<sTasName>; Filename : in String) return <rtlModuleName()>.TEST_CASE_RESULT
is
    decodedPDU  : <sModName>.<sTasName>;
    stream      : <sModName>.<sTasName>_<sEnc>Stream;
    result      : <rtlModuleName()>.ASN1_RESULT;
    ret         : <rtlModuleName()>.TEST_CASE_RESULT;
begin
    <sNestedStatements>
    return ret;
end <sFuncName>;
>>


/*
//////////////////////////// CALL TEST CASES ////////////////////////////////////////////////////////////////////
*/








PrintSuite_call_codec_generate_dat_file(sModName, sTasName, sAmber, sEnc, sStreamName) ::= <<
if result.Success then
    DECLARE
    	stream   : <sModName>.<sTasName>_uPER_Stream;
        ret      : <rtlModuleName()>.ASN1_RESULT;
    begin
        <sModName>.<sTasName>_uPER_Encode(<sValue>, stream, ret);
	    WRITE_STR_TO_FILE(Strm => stream.Data,DataLen => stream.DataLen, fileName => "asn1scc_<sEnc>.dat");
    end;
end if;
>>

                   

PrintATCRunner(sTestSuiteFilename, arrsIncludedModules, arrsVars, arrsTestFunctions, arrsUsedPackages, arrsInitCalls, bGenerateDatFile) ::= <<
pragma Style_Checks (Off);
with Ada.Text_IO;
<if(bGenerateDatFile)>
with Ada.Sequential_IO;
with Interfaces;
use type Interfaces.Unsigned_8;
<endif>
with <rtlModuleName()>;
pragma Warnings (Off, "use clause for type");
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;
pragma Warnings (On, "use clause for type");
<arrsIncludedModules:{inc| with <inc>;}; separator="\n">
<arrsIncludedModules:{inc| use <inc>;}; separator="\n">

function MainProgram return Integer
is
    use Ada.Text_IO;
    <arrsUsedPackages:{p|USE <p>;}; separator="\n">
	pragma Warnings (Off, """totalErrors"" is not modified, could be declared constant");
    totalErrors  : INTEGER:=0;
	pragma Warnings (On, """totalErrors"" is not modified, could be declared constant");
    <arrsVars; separator="\n">
    
<if(bGenerateDatFile)>
    procedure WRITE_STR_TO_FILE(Strm : <rtlModuleName()>.BitArray; 
			        DataLen	: Natural;
                                fileName:String) is
      package Seq_IO is new Ada.Sequential_IO(<rtlModuleName()>.Asn1Byte);
      use Seq_IO;

      MASKS : constant <rtlModuleName()>.OctetBuffer (1 .. 8) := (16#80#, 16#40#, 16#20#, 16#10#, 16#08#, 16#04#, 16#02#, 16#01#);
      curByte:<rtlModuleName()>.Asn1Byte:=0;
      bitIndex:Integer;
      My_Out_File : Seq_IO.FILE_TYPE;
    begin
      Create(My_Out_File, Out_File, fileName);

      for i in 1..DataLen loop
         bitIndex := ((I-1) mod 8) +1;
         if bitIndex = 1 then
            curByte:=0;
         end if;
         if Strm(I)=1 then
           curByte := curByte OR MASKS(bitIndex);
         end if;
         if bitIndex = 8 OR I = DataLen then
            Write(My_Out_File, curByte);
         end if;
      end loop;

      Close(My_Out_File);
    end;

<endif>
begin

    <arrsTestFunctions;separator="\n\n">

    --  used to increase statement coverage
    <arrsInitCalls; separator="\n\n">

    pragma Warnings (Off, "condition can only be True if invalid values present");
    pragma Warnings (Off, "condition is always False");
    if totalErrors > 0 then
        Put_Line (Integer'Image(totalErrors) & " out of <arrsTestFunctions.Length> failed."); 
        return 1;
    else
        Put_Line ("All test cases (<arrsTestFunctions.Length>) run successfully."); 
        return 0;
    end if;
    pragma Warnings (On, "condition can only be True if invalid values present");
    pragma Warnings (On, "condition is always False");
end MainProgram;
>>


PrintATCRunnerDefinition() ::= <<
>>


PrintMain(sTestSuiteFilename) ::= <<
>>

invokeTestCaseAsFunc(sFuncName) ::= <<
<sFuncName> (totalErrors);
>>


emitTestCaseAsFunc_h(sFuncName) ::= <<
procedure <sFuncName> ( totalErrors : in out Integer);
>>

emitTestCaseAsFunc_dummy_init(sTypeName, sFuncName, sDummyVarname) ::= <<
declare
   dummy : <sTypeName>;
begin 
    <sFuncName>(dummy); 
end;
>>

emitTestCaseAsFunc_dummy_init_function(sTypeName, sFuncName, sDummyVarname) ::= <<
declare
   dummy : <sTypeName>;
begin 
    dummy := <sFuncName>; 
end;
>>

emitTestCaseAsFunc(sFuncName, arrsVars, sModName, sTasName, sAmber, sEnc, bValueAssignment, sInitializeTcData, bStatic, sGenerateDatFile, arrsDummyInitStatementsNeededForStatementCoverage, sInitAmber) ::= <<
procedure <sFuncName> ( totalErrors : in out Integer)
is
    use Ada.Text_IO;
    result      : adaasn1rtl.test_case_result;

    s1 : Ada.Calendar.Time;
    s2 : Ada.Calendar.Time;


    <arrsVars; separator="\n">
	pragma Warnings (Off, "there are no others");
    tc_data : <sModName>.<sTasName><if(bValueAssignment)> := <sInitializeTcData><endif>;
	pragma Warnings (On, "there are no others");
	
begin
    <if(arrsDummyInitStatementsNeededForStatementCoverage)>
    --  dummy statement used for calling init functions
    
    <arrsDummyInitStatementsNeededForStatementCoverage; separator="\n">
    <endif>
    --  the actual initialization with the test case data is made here.
	pragma Warnings (Off, "there are no others");
	pragma Warnings (Off, "condition can only be True if invalid values present");
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition is always False");
	pragma Warnings (Off, "condition is always True");
	pragma Warnings (Off, "is always True at this point");
	pragma Warnings (Off, "is always False at this point");
    <if(!bValueAssignment)>
    <sInitializeTcData>

    <else>
    tc_data := <sInitializeTcData>;

    <endif>
	pragma Warnings (On, "there are no others");
	pragma Warnings (On, "condition can only be True if invalid values present");
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition is always False");
	pragma Warnings (On, "condition is always True");
	pragma Warnings (On, "is always True at this point");
	pragma Warnings (On, "is always False at this point");

	pragma Warnings (Off, "object ""tc_data"" is always");
    s1 := Ada.Calendar.Clock;
    result := <sTasName>_<sEnc>enc_dec(tc_data,"<sFuncName>");
    s2 := Ada.Calendar.Clock;
	pragma Warnings (On, "object ""tc_data"" is always");
    if result.Success then
        Put("Test case '<sFuncName>' succeeded, duration was :");
        Put_Line (Duration'Image ((s2 - s1)));
    else
        case result.Step is
            when <rtlModuleName()>.TC_VALIDATE =>
                Put_Line ("Test case '<sFuncName>' failed in validation"); 
            when <rtlModuleName()>.TC_ENCODE =>
                Put_Line ("Test case '<sFuncName>' failed in encoding");
            when <rtlModuleName()>.TC_DECODE =>
                Put_Line ("Test case '<sFuncName>' failed in decoding");
            when <rtlModuleName()>.TC_VALIDATE_DECODED =>
                Put_Line ("Test case '<sFuncName>' failed in the validation of the decoded message");
            when <rtlModuleName()>.TC_EQUAL =>
                Put_Line ("Test case '<sFuncName>' failed. Encoded and decoded messages are different");
        end case;
        Put_Line ("========================================");
        totalErrors := totalErrors + 1;
    end if;
    <sGenerateDatFile>
    
end <sFuncName>;
>>

printTestCaseFileDef(sPackageName, arrsIncludedModules, arrsTestFunctionDefs) ::= <<

package <sPackageName> 
is
<arrsTestFunctionDefs:{tas|<tas>}; separator="\n">

end <sPackageName>;
>>

printTestCaseFileBody(sPackageName, arrsIncludedModules, arrsTestFunctionBodies) ::= <<
pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool (stg macro : printTestCaseFileBody)
with Ada.Text_IO;
with adaasn1rtl;
use adaasn1rtl;
pragma Warnings (Off, "no entities of ""interfaces"" are referenced");
pragma Warnings (Off, "use clause for package ""Interfaces"" has no effect");
with interfaces;
use interfaces;
pragma Warnings (On, "no entities of ""interfaces"" are referenced");
pragma Warnings (On, "use clause for package ""Interfaces"" has no effect");

<arrsIncludedModules:{inc| 
pragma Warnings (Off, "no entities of ""<inc>"" are referenced");
pragma Warnings (Off, "use clause for package ""<inc>"" has no effect");
with <inc>; USE <inc>;
pragma Warnings (On, "no entities of ""<inc>"" are referenced");
pragma Warnings (On, "use clause for package ""<inc>"" has no effect");
}; separator="\n">
with Ada.Calendar;
use Ada.Calendar;

package body <sPackageName> is

<arrsTestFunctionBodies:{vas|<vas>}; separator="\n\n"> 

end <sPackageName>;

>>