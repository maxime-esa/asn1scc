group a_acn;

rtlModuleName() ::= "adaasn1rtl"

EmitAcnParameter(sName, sType) ::= "<sName> : IN <sType>"

EmitTypeAssignment_def_err_code(sErrCode, nErrValue) ::= <<
<sErrCode>:CONSTANT INTEGER := <nErrValue>; 
>>

EmitTypeAssignment_primitive_def_encode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInACN, nMaxBitsInACN, arrsAcnPrms) ::= <<
<arrsErrcodes; separator="\n">
<sTypeDefName>_REQUIRED_BYTES_FOR_ACN_ENCODING:CONSTANT INTEGER := <nMaxBytesInACN>;
<sTypeDefName>_REQUIRED_BITS_FOR_ACN_ENCODING:CONSTANT INTEGER := <nMaxBitsInACN>;

SUBTYPE <sTypeDefName>_ACN_bit_array_range is Natural range 1..<if(bEmptyEncodingSpace)>1<else><sTypeDefName>_REQUIRED_BITS_FOR_ACN_ENCODING<endif>;
SUBTYPE <sTypeDefName>_ACN_bit_array is <rtlModuleName()>.BitArray(<sTypeDefName>_ACN_bit_array_range);


TYPE <sTypeDefName>_ACN_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : <sTypeDefName>_ACN_bit_array;
end RECORD;

procedure <sFuncName>(val:in <sTypeDefName>; Stream : OUT <sTypeDefName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT);
>>

EmitTypeAssignment_primitive_encodeMain(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp, arrsAcnPrms, arrsAcnParamNames) ::= /*nogen*/<<
PROCEDURE <sFuncName>(<sVarName>:in <sTypeDefName>; Stream : OUT <sTypeDefName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT)
IS
BEGIN
    Stream := <sTypeDefName>_ACN_Stream'(K => 0, DataLen => 0, Data => <sTypeDefName>_ACN_bit_array'(others => 0));
    <sTypeDefName>_ACN_Encode_aux(<sVarName>, Stream.Data, Stream.DataLen, result);
END <sFuncName>;
>>

EmitTypeAssignment_primitive_encode(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp, arrsAcnPrms, arrsAcnParamNames) ::= <<
PROCEDURE <sFuncName>_aux(<sVarName>:in <sTypeDefName>; S : in out <rtlModuleName()>.BitArray; K : in out Natural; result : OUT <rtlModuleName()>.ASN1_RESULT)
<soSparkAnnotations>
IS
    <arrsLocalVariables; separator="\n">
BEGIN
    <if(soIValidFuncName)>
    result := <soIValidFuncName>(<sVarName>);
    IF result.success THEN
        <sContent>
    END IF;
    <else>
    result := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
    <sContent>
    <endif>
END <sFuncName>_aux;


<EmitTypeAssignment_primitive_encodeMain(sVarName=sVarName, sStar=sStar, sFuncName=sFuncName, soIValidFuncName=soIValidFuncName, sTypeDefName=sTypeDefName, arrsLocalVariables=arrsLocalVariables, sContent=sContent, soSparkAnnotations=soSparkAnnotations, sInitilialExp=sInitilialExp, arrsAcnPrms=arrsAcnPrms, arrsAcnParamNames=arrsAcnParamNames)>
>>



EmitTypeAssignment_primitive_def_decode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInACN, nMaxBitsInACN, arrsAcnPrms) ::= <<
<arrsErrcodes; separator="\n">
procedure <sFuncName>(<sVarName>: out <sTypeDefName>; Stream : IN <sTypeDefName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsAcnPrms)>; <arrsAcnPrms; separator="; "><endif>);
>>

EmitTypeAssignment_primitive_decodeMain(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp, arrsAcnPrms, arrsAcnParamNames) ::= /*nogen*/<<
PROCEDURE <sFuncName>(<sVarName>: out <sTypeDefName>; Stream : IN <sTypeDefName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsAcnPrms)>; <arrsAcnPrms; separator="; "><endif>)
IS
    iter:<rtlModuleName()>.DECODE_PARAMS;
BEGIN
    iter := <rtlModuleName()>.DECODE_PARAMS'(K => 0, DataLen => Stream.DataLen);
    <sFuncName>_aux(<sVarName>, Stream.Data, iter, result<if(arrsAcnParamNames)>, <arrsAcnParamNames; separator=","><endif>);
    result.Success := result.Success AND iter.K\<=iter.DataLen;
    <if(soIValidFuncName)>
    if result.success then
        result := <soIValidFuncName>(<sVarName>);
    end if;

    <endif>
END <sFuncName>;
>>

EmitTypeAssignment_primitive_decode(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp, arrsAcnPrms, arrsAcnParamNames) ::= <<
pragma Warnings (Off, "unused initial value of ""<sVarName>""");
PROCEDURE <sFuncName>_aux(<sVarName>:out <sTypeDefName>; S : in <rtlModuleName()>.BitArray; K : in out <rtlModuleName()>.DECODE_PARAMS; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsAcnPrms)>; <arrsAcnPrms; separator="; "><endif>)
<soSparkAnnotations>
IS
    <arrsLocalVariables; separator="\n">
BEGIN
    <sContent>
END <sFuncName>_aux;
pragma Warnings (On, "unused initial value of ""<sVarName>""");

<EmitTypeAssignment_primitive_decodeMain(sVarName=sVarName, sStar=sStar, sFuncName=sFuncName, soIValidFuncName=soIValidFuncName, sTypeDefName=sTypeDefName, arrsLocalVariables=arrsLocalVariables, sContent=sContent, soSparkAnnotations=soSparkAnnotations, sInitilialExp=sInitilialExp, arrsAcnPrms=arrsAcnPrms, arrsAcnParamNames=arrsAcnParamNames)>
>>





MF(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
IF Result.Success THEN
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
    Result.Success := <p> \>= <nUperMin> AND <p> \<= <nUperMax>;
    IF NOT Result.Success THEN
        <p> := <nUperMin>;
        Result.ErrorCode := ERR_INCORRECT_STREAM;
    END IF;
END IF;
>>

MFen(soMF, soMFM, p) ::= "<if(soMF)><soMFM>.<soMF>_encode(<p>)<else><p><endif>"


alignToNext_encode(sMainBody, sAligmentValue, nAligmentValue) ::= <<
--align to next <sAligmentValue>
if (K mod <nAligmentValue>) /= 0 then
    K := K + (<nAligmentValue> - (K mod <nAligmentValue>));
end if;
<sMainBody>
>>


alignToNext_decode(sMainBody, sAligmentValue, nAligmentValue) ::= <<
--align to next <sAligmentValue>
if (K.K mod <nAligmentValue>) /= 0 then
    K.K := K.K + (<nAligmentValue> - (K.K mod <nAligmentValue>));
end if;
<sMainBody>
>>


PositiveInteger_ConstSize_encode(p, sErrCode, nFixedSize, soMF, soMFM, nUperMin, nUperMax) ::= <<
<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nFixedSize>);
>>

PositiveInteger_ConstSize_decode(p, sErrCode, nFixedSize, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize(S, K, mapFuncIntVal, 0, 0, Asn1Int(2)**<nFixedSize> - 1, <nFixedSize>, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize(S, K, <p>, <nUperMin>, <nUperMax>, <nFixedSize>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_ConstSize_8_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_8(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_8_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_8(S, K, mapFuncIntVal, 0, 0, Asn1Int(255), result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_8(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_ConstSize_big_endian_16_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_big_endian_16_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(S, K, mapFuncIntVal, 0, 0, Asn1Int(65535), result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>


PositiveInteger_ConstSize_big_endian_32_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_big_endian_32_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(S, K, mapFuncIntVal, 0, 0, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_ConstSize_big_endian_64_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_64(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_big_endian_64_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64(S, K, mapFuncIntVal, 0, 0, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_ConstSize_little_endian_16_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_16(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_little_endian_16_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16(S, K, mapFuncIntVal, 0, 0, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_ConstSize_little_endian_32_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_little_endian_32_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(S, K, mapFuncIntVal, 0, 0, Asn1Int'Last,  result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(S, K, <p>, <nUperMin>, <nUperMax>,  result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_ConstSize_little_endian_64_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_64(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_little_endian_64_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64(S, K, mapFuncIntVal, 0, 0, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_VarSize_LengthEmbedded_encode(p, sErrCode, soMF, soMFM, nUperMin) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_VarSize_LengthEmbedded(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_VarSize_LengthEmbedded_decode(p, sErrCode, soMF, soMFM, nUperMin) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_VarSize_LengthEmbedded(S, K, mapFuncIntVal, 0, 0, result);
IF Result.Success THEN
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
    Result.Success := <p> \>= <nUperMin>;
    IF NOT Result.Success THEN
        <p> := <nUperMin>;
        result.ErrorCode := <sErrCode>;
    END IF;
END IF;

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_VarSize_LengthEmbedded(S, K, <p>, <nUperMin>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>


TwosComplement_ConstSize_encode(p, sErrCode, soMF, soMFM, nFixedSize, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nFixedSize>);"
TwosComplement_ConstSize_decode(p, sErrCode, soMF, soMFM, nFixedSize, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, <nFixedSize>, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize(S, K, <p>, <nUperMin>, <nUperMax>, <nFixedSize>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_8_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_8(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_8_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_8(S, K, mapFuncIntVal, -Asn1Int(128), Asn1Int(127), result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_8(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_big_endian_16_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_big_endian_16(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_big_endian_16_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_16(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_16(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_big_endian_32_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_big_endian_32(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_big_endian_32_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_32(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_32(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_big_endian_64_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_big_endian_64(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_big_endian_64_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_64(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_64(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_little_endian_16_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_little_endian_16(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_little_endian_16_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_16(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_16(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_little_endian_32_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_little_endian_32(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_little_endian_32_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_32(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_32(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_little_endian_64_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_little_endian_64(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_little_endian_64_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_64(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_64(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_VarSize_LengthEmbedded_encode(p, sErrCode, soMF, soMFM) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_VarSize_LengthEmbedded(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_VarSize_LengthEmbedded_decode(p, sErrCode, soMF, soMFM) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_VarSize_LengthEmbedded(S, K, <p>, result);
result.ErrorCode := <sErrCode>;
IF Result.Success THEN
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
END IF;

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_VarSize_LengthEmbedded(S, K, <p>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>


BCD_ConstSize_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax, nNibbles) ::= "<rtlModuleName()>.Acn_Enc_Int_BCD_ConstSize(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nNibbles>);"
BCD_ConstSize_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax, nNibbles) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_BCD_ConstSize(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, <nNibbles>, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_BCD_ConstSize(S, K, <p>, <nUperMin>, <nUperMax>, <nNibbles>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

BCD_VarSize_LengthEmbedded_encode(p, sErrCode, soMF, soMFM) ::= "<rtlModuleName()>.Acn_Enc_Int_BCD_VarSize_LengthEmbedded(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
BCD_VarSize_LengthEmbedded_decode(p, sErrCode, soMF, soMFM) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_BCD_VarSize_LengthEmbedded(S, K, mapFuncIntVal, result);
result.ErrorCode := <sErrCode>;
IF Result.Success THEN
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
END IF;

<else>
<rtlModuleName()>.Acn_Dec_Int_BCD_VarSize_LengthEmbedded(S, K, <p>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

BCD_VarSize_NullTerminated_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_BCD_VarSize_NullTerminated(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
BCD_VarSize_NullTerminated_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_BCD_VarSize_NullTerminated(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_BCD_VarSize_NullTerminated(S, K, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

ASCII_ConstSize_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= "<rtlModuleName()>.Acn_Enc_Int_ASCII_ConstSize(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nSizeInBytes>);"
ASCII_ConstSize_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_ASCII_ConstSize(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, <nSizeInBytes>, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_ASCII_ConstSize(S, K, <p>, <nUperMin>, <nUperMax>, <nSizeInBytes>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>


ASCII_UINT_ConstSize_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= "<rtlModuleName()>.Acn_Enc_UInt_ASCII_ConstSize(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nSizeInBytes>);"
ASCII_UINT_ConstSize_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_UInt_ASCII_ConstSize(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, <nSizeInBytes>, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_UInt_ASCII_ConstSize(S, K, <p>, <nUperMin>, <nUperMax>, <nSizeInBytes>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>



ASCII_VarSize_LengthEmbedded_encode(p, sErrCode, soMF, soMFM) ::= "<rtlModuleName()>.Acn_Enc_Int_ASCII_VarSize_LengthEmbedded(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
ASCII_VarSize_LengthEmbedded_decode(p, sErrCode, soMF, soMFM) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_ASCII_VarSize_LengthEmbedded(S, K, mapFuncIntVal, result);
result.ErrorCode := <sErrCode>;
IF Result.Success THEN
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
END IF;

<else>
<rtlModuleName()>.Acn_Dec_Int_ASCII_VarSize_LengthEmbedded(S, K, <p>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

ASCII_VarSize_NullTerminated_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax, sNullChar) ::= "<rtlModuleName()>.Acn_Enc_Int_ASCII_VarSize_NullTerminated(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <sNullChar>);"
ASCII_VarSize_NullTerminated_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax, sNullChar) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_ASCII_VarSize_NullTerminated(S, K, mapFuncIntVal, <sNullChar>, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_ASCII_VarSize_NullTerminated(S, K, <p>, <sNullChar>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>


ASCII_UINT_VarSize_NullTerminated_encode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax, sNullCharacter) ::= "<rtlModuleName()>.Acn_Enc_UInt_ASCII_VarSize_NullTerminated(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <sNullCharacter>);"
ASCII_UINT_VarSize_NullTerminated_decode(p, sErrCode, soMF, soMFM, nUperMin, nUperMax, sNullCharacter) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_UInt_ASCII_VarSize_NullTerminated(S, K, mapFuncIntVal, <sNullCharacter>, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_UInt_ASCII_VarSize_NullTerminated(S, K, <p>, <sNullCharacter>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>


/************************ OLD macros ***********************************************************************/





Real_32_big_endian_encode(p, sErrCode) ::= "<rtlModuleName()>.Acn_Enc_Real_IEEE754_32_big_endian(S, K, <p>);"
Real_32_big_endian_decode(p, sErrCode) ::= <<
<rtlModuleName()>.Acn_Dec_Real_IEEE754_32_big_endian(S, K, <p>, result);
result.ErrorCode := <sErrCode>;
>>

Real_64_big_endian_encode(p, sErrCode) ::= "<rtlModuleName()>.Acn_Enc_Real_IEEE754_64_big_endian(S, K, <p>);"
Real_64_big_endian_decode(p, sErrCode) ::= <<
<rtlModuleName()>.Acn_Dec_Real_IEEE754_64_big_endian(S, K, <p>, result);
result.ErrorCode := <sErrCode>;
>>

Real_32_little_endian_encode(p, sErrCode) ::= "<rtlModuleName()>.Acn_Enc_Real_IEEE754_32_little_endian(S, K, <p>);"
Real_32_little_endian_decode(p, sErrCode) ::= <<
<rtlModuleName()>.Acn_Dec_Real_IEEE754_32_little_endian(S, K, <p>, result);
result.ErrorCode := <sErrCode>;
>>

Real_64_little_endian_encode(p, sErrCode) ::= "<rtlModuleName()>.Acn_Enc_Real_IEEE754_64_little_endian(S, K, <p>);"
Real_64_little_endian_decode(p, sErrCode) ::= <<
<rtlModuleName()>.Acn_Dec_Real_IEEE754_64_little_endian(S, K, <p>, result);
result.ErrorCode := <sErrCode>;
>>




Boolean_encode(p, ptr, bTruePattern, nSize, arruTrueValueAsByteArray, arruFalseValueAsByteArray, arrsBits, sErrCode) ::= <<
<if(bTruePattern)>
<rtlModuleName()>.Acn_Enc_Boolean_true_pattern(S, K, <p>, BitArray'(<arrsBits; separator=",">));

<else>
<rtlModuleName()>.Acn_Enc_Boolean_false_pattern(S, K, <p>, BitArray'(<arrsBits; separator=",">));

<endif>
>>

Boolean_decode(p, ptr, bTruePattern, nSize, arruTrueValueAsByteArray, arruFalseValueAsByteArray, arrsBits, sErrCode) ::= <<
<if(bTruePattern)>
<rtlModuleName()>.Acn_Dec_Boolean_true_pattern(S, K, <p>, BitArray'(<arrsBits; separator=",">), result);

<else>
<rtlModuleName()>.Acn_Dec_Boolean_false_pattern(S, K, <p>, BitArray'(<arrsBits; separator=",">), result);

<endif>
result.ErrorCode := <sErrCode>;
>>


Null_pattern_encode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode) ::= <<
<rtlModuleName()>.Acn_Enc_NullType_pattern(S, K, <p>, BitArray'(<arrsBits; separator=",">));
>>

Null_pattern_decode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode) ::= <<
<rtlModuleName()>.Acn_Dec_NullType_pattern(S, K, <p>, BitArray'(<arrsBits; separator=",">), result);
result.ErrorCode := <sErrCode>;
>>



Null_pattern2_encode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode) ::= <<
<rtlModuleName()>.Acn_Enc_NullType_pattern2(S, K, BitArray'(<arrsBits; separator=",">));
>>

Null_pattern2_decode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode) ::= <<
<rtlModuleName()>.Acn_Dec_NullType_pattern2(S, K, BitArray'(<arrsBits; separator=",">), result);
result.ErrorCode := <sErrCode>;
>>


Null2_encode() ::= <<
 -- encoding NULL, nothing to do
>>

Null2_decode() ::= <<
 -- decoding NULL, nothing to do
>>


Null_encode(p) ::= <<
<rtlModuleName()>.Acn_Enc_NullType(S, K, <p>);
>>

Null_decode(p) ::= <<
<rtlModuleName()>.Acn_Dec_NullType(S, K, <p>, result);
>>




Enumerated_item_encode(p, sName, nItemIdxOrVal) ::= "when <sName>    => intVal := <nItemIdxOrVal>;"

Enumerated_item_decode(p, sName, nItemIdxOrVal) ::= "when <nItemIdxOrVal> => <p> := <sName>;"

EnumeratedEncIdx_encode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, sActualCodecFunc) ::= <<
case <p> is 
    <arrsItem; separator="\n">
end case;
<sActualCodecFunc>
>>

EnumeratedEncIdx_decode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, sActualCodecFunc) ::= <<
<p> := <td.typeName>_Init;
<sActualCodecFunc>
IF result.Success THEN
    case <td.index_range>(intVal) is
        <arrsItem; separator="\n">
    end case;
END IF;
>>


EnumeratedEncValues_encode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, sActualCodecFunc, sErrCode, sFirstItemName) ::= <<
<EnumeratedEncIdx_encode(p=p, td=td, arrsItem=arrsItem, sActualCodecFunc=sActualCodecFunc)>
>>

EnumeratedEncValues_decode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, sActualCodecFunc, sErrCode, sFirstItemName) ::= <<
<sActualCodecFunc>
if result.Success then
    case intVal is
        <arrsItem; separator="\n">
    when others =>
        <p> := <sFirstItemName>;
        result := <rtlModuleName()>.ASN1_RESULT'(Success => False, ErrorCode => <sErrCode>);
    end case;
else
    <p> := <sFirstItemName>;
    result.ErrorCode := <sErrCode>;
end if;
>>


// Strings



Acn_String_Ascii_FixSize_encode(p, sErrCode, nAsn1Max) ::= "<rtlModuleName()>.Acn_Enc_String_Ascii_FixSize(S, K, <p>);"
Acn_String_Ascii_FixSize_decode(p, sErrCode, nAsn1Max) ::= <<
<rtlModuleName()>.Acn_Dec_String_Ascii_FixSize(S, K, <p>, result);
result.ErrorCode := <sErrCode>;
>>

Acn_String_Ascii_Null_Teminated_encode(p, sErrCode, nAsn1Max, sNull) ::= "<rtlModuleName()>.Acn_Enc_String_Ascii_Null_Teminated(S, K, <sNull>, <p>);"
Acn_String_Ascii_Null_Teminated_decode(p, sErrCode, nAsn1Max, sNull) ::= <<
<rtlModuleName()>.Acn_Dec_String_Ascii_Null_Teminated(S, K, <sNull>, <p>, result);
result.ErrorCode := <sErrCode>;
>>


Acn_String_Ascii_External_Field_Determinant_encode(p, sErrCode, nAsn1Max, sExtFld) ::= "<rtlModuleName()>.Acn_Enc_String_Ascii_External_Field_Determinant(S, K, <p>);"
Acn_String_Ascii_External_Field_Determinant_decode(p, sErrCode, nAsn1Max, sExtFld) ::= <<
<rtlModuleName()>.Acn_Dec_String_Ascii_External_Field_Determinant(S, K, <rtlModuleName()>.Asn1Int(<sExtFld>), <p>, result);
result.ErrorCode := <sErrCode>;
>>


Acn_String_Ascii_Internal_Field_Determinant_encode(p, sErrCode, nAsn1Max, nAsn1Min, nInternalLengthDeterminantSizeInBits) ::= "<rtlModuleName()>.Acn_Enc_String_Ascii_Internal_Field_Determinant(S, K, <nAsn1Min>, <nInternalLengthDeterminantSizeInBits>, <p>);"
Acn_String_Ascii_Internal_Field_Determinant_decode(p, sErrCode, nAsn1Max, nAsn1Min, nInternalLengthDeterminantSizeInBits) ::= <<
<rtlModuleName()>.Acn_Dec_String_Ascii_Internal_Field_Determinant(S, K, <nAsn1Min>, <nAsn1Max>, <nInternalLengthDeterminantSizeInBits>, <p>, result);
result.ErrorCode := <sErrCode>;
>>



Acn_String_CharIndex_FixSize_encode(p, sErrCode, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, td/*:FE_StringTypeDefinition*/, nCharSize) ::= "<rtlModuleName()>.Acn_Enc_String_CharIndex_FixSize(S, K, <td.alpha_set>, <nCharSize>, <p>);"
Acn_String_CharIndex_FixSize_decode(p, sErrCode, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, td/*:FE_StringTypeDefinition*/, nCharSize) ::= <<
<rtlModuleName()>.Acn_Dec_String_CharIndex_FixSize(S, K, <td.alpha_set>, <nCharSize>, <p>, result);
result.ErrorCode := <sErrCode>;
>>


Acn_String_CharIndex_External_Field_Determinant_encode(p, sErrCode, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, sExtFld, td/*:FE_StringTypeDefinition*/, nCharSize) ::= "<rtlModuleName()>.Acn_Enc_String_CharIndex_External_Field_Determinant(S, K, <td.alpha_set>, <nCharSize>, <p>);"
Acn_String_CharIndex_External_Field_Determinant_decode(p, sErrCode, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, sExtFld, td/*:FE_StringTypeDefinition*/, nCharSize) ::= <<
<rtlModuleName()>.Acn_Dec_String_CharIndex_External_Field_Determinant(S, K, <td.alpha_set>, <nCharSize>, <rtlModuleName()>.Asn1Int(<sExtFld>), <p>, result);
result.ErrorCode := <sErrCode>;
>>


Acn_IA5String_CharIndex_External_Field_Determinant_encode(p, sErrCode, nAsn1Max, sExtFld, td/*:FE_StringTypeDefinition*/, nCharSize) ::= "<rtlModuleName()>.Acn_Enc_String_CharIndex_External_Field_Determinant(S, K, <td.alpha_set>, <nCharSize>, <p>);"
Acn_IA5String_CharIndex_External_Field_Determinant_decode(p, sErrCode, nAsn1Max, sExtFld, td/*:FE_StringTypeDefinition*/, nCharSize) ::= <<
<rtlModuleName()>.Acn_Dec_String_CharIndex_External_Field_Determinant(S, K, <td.alpha_set>, <nCharSize>, <rtlModuleName()>.Asn1Int(<sExtFld>), <p>, result);
result.ErrorCode := <sErrCode>;
>>



Acn_String_CharIndex_Internal_Field_Determinant_encode(p, sErrCode, td/*:FE_StringTypeDefinition*/, nCharSize, nAsn1Max, nAsn1Min, nInternalLengthDeterminantSizeInBits) ::= "<rtlModuleName()>.Acn_Enc_String_CharIndex_Internal_Field_Determinant(S, K, <td.alpha_set>, <nCharSize>, <nAsn1Min>, <nInternalLengthDeterminantSizeInBits>, <p>);"
Acn_String_CharIndex_Internal_Field_Determinant_decode(p, sErrCode, td/*:FE_StringTypeDefinition*/, nCharSize, nAsn1Max, nAsn1Min, nInternalLengthDeterminantSizeInBits) ::= <<
<rtlModuleName()>.Acn_Dec_String_CharIndex_Internal_Field_Determinant(S, K, <td.alpha_set>, <nCharSize>, <nAsn1Min>, <nAsn1Max>, <nInternalLengthDeterminantSizeInBits>, <p>, result);
result.ErrorCode := <sErrCode>;
>>






loopFixedItem_enc (i, fixedSize, nfixedSizeUperLimit, sInternalItem, nCurOffset, nAlignSize, nIntItemMinSize, nIntItemMaxSize)::= /*nogen*/<<    
<i> := 1;
while <i>\<= <fixedSize> loop
    pragma Loop_Invariant (<i> >=1 and <i>\<=<fixedSize>);
    pragma Loop_Invariant (K >= K'Loop_Entry);
    pragma Loop_Invariant (K\<=K'Loop_Entry + <nIntItemMaxSize>*(<i>-1));
    <sInternalItem>
    <i> := <i> + 1;
end loop;
>>

loopFixedItem_dec (i, fixedSize, nfixedSizeUperLimit, sInternalItem, nCurOffset, nAlignSize, nIntItemMinSize, nIntItemMaxSize)::= /*nogen*/<<    
<i> := 1;
while <i>\<= <fixedSize> AND result.Success loop
    pragma Loop_Invariant (<i> >=1 and <i>\<=<fixedSize>);
    pragma Loop_Invariant (K.K >= K'Loop_Entry.K);
    pragma Loop_Invariant (K.K \<= K'Loop_Entry.K + <nIntItemMaxSize>*(<i>-1));
    <sInternalItem>
    <i> := <i> + 1;
end loop;
>>



/* Strings */









oct_sqf_external_field_encode(p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, sExtFld, nAlignSize, sErrCode, nIntItemMinSize, nIntItemMaxSize) ::= <<
<loopFixedItem_enc(i=i, sInternalItem=sInternalItem, fixedSize=[p,".Length"], nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
>>


oct_sqf_external_field_decode(p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, sExtFld, nAlignSize, sErrCode, nIntItemMinSize, nIntItemMaxSize) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <if(noSizeMin)><noSizeMin>\<=<sExtFld> AND <endif><sExtFld>\<=<nSizeMax>, ErrorCode => <sErrCode>);
IF result.Success THEN
    <p>.Length := Integer(<sExtFld>);
    <loopFixedItem_dec(i=i, sInternalItem=sInternalItem, fixedSize=[p,".Length"], nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
END IF;
>>




RefTypeParam_tmpVar(sName, sTypeDecl) ::= "<sName>:<sTypeDecl>;"

ReferenceType1_encode(p, sName, bAcnEncodeFuncRequiresResult, arrsArgs, arrsLocalPrms) ::= <<
<arrsLocalPrms, arrsArgs: {lp,arg|<if(arg)><lp> := <arg>;-- 3031<endif>}; separator="\n">
<sName>_ACN_Encode_aux(<p>, S, K<if(bAcnEncodeFuncRequiresResult)>, result<endif><if(arrsArgs)>, <arrsLocalPrms; separator=", "><endif>);
>>

ReferenceType1_decode(p, sName, bAcnEncodeFuncRequiresResult, arrsArgs, arrsLocalPrms) ::= <<
<arrsLocalPrms, arrsArgs: {lp,arg|<if(arg)><lp> := <arg>; -- 3030<endif>}; separator="\n">
<sName>_ACN_Decode_aux(<p>, S, K, result<if(arrsArgs)>, <arrsLocalPrms; separator=", "><endif>);
>>

ReferenceType2_encode(p, sTasName, sName, bAcnEncodeFuncRequiresResult, arrsArgs, arrsLocalPrms) ::= "<sTasName>.<ReferenceType1_encode(p=p, sName=sName, bAcnEncodeFuncRequiresResult = bAcnEncodeFuncRequiresResult, arrsArgs=arrsArgs, arrsLocalPrms=arrsLocalPrms)>"

ReferenceType2_decode(p, sTasName, sName, bAcnEncodeFuncRequiresResult, arrsArgs, arrsLocalPrms) ::= "<sTasName>.<ReferenceType1_decode(p=p, sName=sName, bAcnEncodeFuncRequiresResult = bAcnEncodeFuncRequiresResult, arrsArgs=arrsArgs, arrsLocalPrms=arrsLocalPrms)>"


/* SEQUENCE*/

sequence_presense_optChild_encode(p, sAcc, sChName, sErrCode) ::= "<rtlModuleName()>.BitStream_AppendBit(S, K,<p>.Exist.<sChName>);"
sequence_presense_optChild_decode(p, sAcc, sChName, sErrCode) ::= <<
result.ErrorCode := <sErrCode>;
<rtlModuleName()>.BitStream_ReadBit(S, K,<p>.Exist.<sChName>, result.Success);
>>

sequence_presense_optChild_pres_bool_encode(p, sAcc, sChName, sExtFldName) ::= ""
sequence_presense_optChild_pres_bool_decode(p, sAcc, sChName, sExtFldName) ::= <<
<p>.Exist.<sChName> := (if <sExtFldName> then 1 else 0);
result.Success := true;
>>

sequence_presense_optChild_pres_int_encode(p, sAcc, sChName, sExtFldName, nIntVal) ::= ""
sequence_presense_optChild_pres_int_decode(p, sAcc, sChName, sExtFldName, nIntVal) ::= <<
<p>.Exist.<sChName> := (if <sExtFldName> = <nIntVal> then 1 else 0);
result.Success := true;
>>

sequence_presense_optChild_pres_str_encode(p, sAcc, sChName, sExtFldName, sVal) ::= ""
sequence_presense_optChild_pres_str_decode(p, sAcc, sChName, sExtFldName, sVal) ::= <<
<p>.Exist.<sChName> := (if <sExtFldName> = "<nIntVal>" then 1 else 0);
result.Success := true;
>>

sequence_acn_child_encode(sChName, sChildContent, sErrCode) ::= <<
--Encode <sChName> 
if <sChName>_is_initialized then
    result := <rtlModuleName()>.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);
    <sChildContent>
else
    result := <rtlModuleName()>.ASN1_RESULT'(Success => False, ErrorCode => <sErrCode>);
end if;
>>
sequence_acn_child_decode(sChName, sChildContent, sErrCode) ::= <<
--Decode <sChName> 
<sChildContent>
>>


sequence_mandatory_child_encode(sChName, sChildContent) ::= <<
-- Encode <sChName> 
<sChildContent>
>>
sequence_mandatory_child_decode(sChName, sChildContent) ::= <<
-- Decode <sChName> 
<sChildContent>
>>

sequence_always_present_child_encode(p, sAcc, sChName, sChildContent) ::= <<
-- Encode <sChName>
-- marked as ALWAYS PRESENT, so do not look in exist
<sChildContent>
>>

sequence_always_present_child_decode(p, sAcc, sChName, sChildContent) ::= <<
-- Decode <sChName>
-- marked as ALWAYS PRESENT, so do not look in exist
<p>.Exist.<sChName> := 1; 
<sChildContent>
>>

sequence_always_absent_child_encode(p, sAcc, sChName, sChildContent) ::= <<
-- Encode <sChName>
-- marked as ALWAYS ABSENT, so do not encode anything
null;
>>

sequence_always_absent_child_decode(p, sAcc, sChName, sChildContent) ::= <<
-- Decode <sChName>
-- marked as ALWAYS ABSENT, so do not decode anything
<p>.Exist.<sChName> := 0;
>>


sequence_optional_child_encode(p, sAcc, sChName, sChildContent) ::= <<
-- Encode <sChName>
if <p>.Exist.<sChName> = 1 then
	<sChildContent>
end if;
>>

sequence_optional_child_decode(p, sAcc, sChName, sChildContent) ::= <<
-- Decode <sChName>
if <p>.Exist.<sChName> = 1 then
	<sChildContent>
end if;
>>


sequence_optional_always_present_child_encode(p, sAcc, sChName, sChildContent) ::= <<
-- Encode <sChName> (always present, do not check for presence)
<sChildContent>
>>

sequence_optional_always_present_child_decode(p, sAcc, sChName, sChildContent) ::= <<
-- Decode <sChName> (always present, do not check for presence)
<p>.Exist.<sChName> := 1;
<sChildContent>
>>


sequence_default_child_encode(p, sAcc, sChName, sChildContent, sInitWithDefaultValue) ::= <<
<sequence_optional_child_encode(p=p, sAcc=sAcc, sChName=sChName, sChildContent=sChildContent)>
>>


sequence_default_child_decode(p, sAcc, sChName, sChildContent, sInitWithDefaultValue) ::= <<
-- Decode <sChName>
if <p>.Exist.<sChName> = 1 then
	<sChildContent>
else
    <sInitWithDefaultValue>
end if;
>>




Sequence_encode(p, arrsChildren, sTasName, bRequiresInit, arrsDecOutParamsInit, bResultRequiresInit) ::= <<
<if(arrsChildren)>
<arrsChildren; separator="\n">

<else>
null;

<endif>
>>


PrmUpdate(sPrmName, sPrmInitValue) ::= "<sPrmName> := <sPrmInitValue>;"

Sequence_decode(p, arrsChildren, sTasName, bRequiresInit, arrsDecOutParamsInit, bResultRequiresInit) ::= <<
<if(bRequiresInit)>val := <sTasName>_Init;<endif>
<arrsDecOutParamsInit; separator="\n">
<if(bResultRequiresInit)>
result := <rtlModuleName()>.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);

<endif>
<arrsChildren; separator="\n">
>>



JoinItems_encode(sTasName, sPart, sNestedPart, nRequiredBitsSoFar, bRequiresAssert,  bReqResultCheck) ::= <<
<sPart>
<if(sNestedPart)>
<if(bRequiresAssert)>
--# assert K~+1>= S'First and K~ + <sTasName>_REQUIRED_BITS_FOR_ACN_ENCODING \<= S'Last AND
--#	       K>=K~ and K\<=K~+<nRequiredBitsSoFar>;

<endif>
<if(bReqResultCheck)>
IF result.Success THEN
    <sNestedPart>
END IF;
<else>
<sNestedPart>
<endif>
<endif>
>>


UpdateFailedPart()::="result.ErrorCode := <rtlModuleName()>.ERR_INCORRECT_DATA;"

JoinItems_decode(sTasName, sPart, sNestedPart, nRequiredBitsSoFar, bRequiresAssert, bReqResultCheck) ::= <<
<sPart>
<if(sNestedPart)>
<if(bRequiresAssert)>
--# assert K~.K+1>= S'First and K~.K + <sTasName>_REQUIRED_BITS_FOR_ACN_ENCODING \<= S'Last AND
--#	       K.K>=K~.K and K.K\<=K~.K+<nRequiredBitsSoFar>;	

<endif>
<if(bReqResultCheck)>
IF result.Success THEN
    <sNestedPart>
END IF;
<else>
<sNestedPart>
<endif>
<endif>
>>


/* Choice like uper*/

Choice_encode(p, sAcc, arrsChildren, nLastItemIndex, sChoiceIndexName, td/*:FE_ChoiceTypeDefinition*/, nIndexSizeInBits, sErrCode) ::= <<
case <p><sAcc>kind IS
    <arrsChildren; separator="\n">
end case;
>>

Choice_decode(p, sAcc, arrsChildren, nLastItemIndex, sChoiceIndexName, td/*:FE_ChoiceTypeDefinition*/, nIndexSizeInBits, sErrCode) ::= <<
result.ErrorCode := <sErrCode>;
<rtlModuleName()>.UPER_Dec_ConstraintWholeNumber(S, K, <sChoiceIndexName>, 0, <nLastItemIndex>, <nIndexSizeInBits>, result.Success);
if result.Success AND <sChoiceIndexName> \>= 0 AND  <sChoiceIndexName> \<= <nLastItemIndex> THEN
    case <td.index_range>(<sChoiceIndexName>) IS
        <arrsChildren; separator="\n">
    end case;
end if;
>>

ChoiceChildAlwaysAbsent_encode(p, sAcc, sChildID, nChildIndex, sErrorCodeName) ::= <<
when <sChildID> =>
    result := <rtlModuleName()>.ASN1_RESULT'(Success => false, ErrorCode => <sErrorCodeName>);
>>

ChoiceChildAlwaysAbsent_decode(p, sAcc, sChildID, nChildIndex, sErrorCodeName) ::= <<
when <nChildIndex> =>
    result := <rtlModuleName()>.ASN1_RESULT'(Success => false, ErrorCode => <sErrorCodeName>);
>>


ChoiceChild_encode(p, sAcc, sChildID, nChildIndex, nIndexSizeInBits, nLastItemIndex, sChildContent, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
when <sChildID> =>
    <rtlModuleName()>.UPER_Enc_ConstraintWholeNumber(S, K, <nChildIndex>, 0, <nIndexSizeInBits>);
	<sChildContent>
>>

ChoiceChild_decode(p, sAcc, sChildID, nChildIndex, nIndexSizeInBits, nLastItemIndex, sChildContent, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
when <nChildIndex> =>
  declare
     <sChildName>_tmp:<sChildTypeDef>;
  begin
    <sChildContent>
    if result.Success then
        <p> := <sChoiceTypeName>'(kind => <sChildID>, <sChildName> => <sChildName>_tmp);
        pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
    end if;
  end;
>>

/* Choice with Enum determinant */

ChoiceChild_Enum_encode(p, sAcc, sEnmName, sChildID, sChildBody, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
when <sChildID> =>
	<sChildBody>
>>

ChoiceChild_Enum_decode(p, sAcc, sEnmName, sChildID, sChildBody, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
when <sEnmName> =>
  declare
     <sChildName>_tmp:<sChildTypeDef>;
  begin
    <sChildBody>
    if result.Success then
        <p> := <sChoiceTypeName>'(kind => <sChildID>, <sChildName> => <sChildName>_tmp);
        pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
    end if;
  end;
>>

Choice_Enum_encode(p, sAcc, arrsChildren, sEnmExtFld, sErrCode) ::= <<
case <p><sAcc>kind IS
    <arrsChildren; separator="\n">
end case;
>>

Choice_Enum_decode(p, sAcc, arrsChildren, sEnmExtFld, sErrCode) ::= <<
case <sEnmExtFld> IS
    <arrsChildren; separator="\n">
end case;
>>




/* Choice with presense determinants */


ChoiceChild_preWhen_bool_condition(sExtFld) ::= "<sExtFld>"
ChoiceChild_preWhen_int_condition(sExtFld, nVal) ::= "(<sExtFld> = <nVal>)"
ChoiceChild_preWhen_str_condition(sExtFld, sVal, arrsNullChars) ::= "(<sExtFld> = \"<sVal>\"<if(arrsNullChars)> & <arrsNullChars; wrap, anchor, separator=\" & \"><endif>)"

Choice_preWhen_encode(p, sAcc, arrsChildren, sErrCode) ::= <<
case <p><sAcc>kind IS
    <arrsChildren; separator="\n">
end case;
>>

ChoiceChild_preWhen_encode(p, sAcc, sChildID, sChildBody, arrsConditions, bFirst, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
when <sChildID> =>
	<sChildBody>
>>



Choice_preWhen_decode(p, sAcc, arrsChildren, sErrCode) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
<arrsChildren; separator="\n">
else
    result := <rtlModuleName()>.ASN1_RESULT'(Success => false, ErrorCode => <sErrCode>); 
end if;
>>

ChoiceChild_preWhen_decode(p, sAcc, sChildID, sChildBody, arrsConditions, bFirst, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
<if(bFirst)>if<else>elsif<endif> (<arrsConditions; separator=" and ">) then
  declare
     <sChildName>_tmp:<sChildTypeDef>;
  begin
    <sChildBody>
    if result.Success then
        <p> := <sChoiceTypeName>'(kind => <sChildID>, <sChildName> => <sChildName>_tmp);
        pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
    end if;
  end;
>>





ChoiceChild_tmpVar(sName, sTypeDecl) ::= "<sName>_tmp:<sTypeDecl>;"


Declare_ChoiceIndex()::="index:<rtlModuleName()>.Asn1Int;"



/* Updates */


MultiAcnUpdate_checkEqual_pri0(p1,p2) ::= "(<p1> = <p2>)"
MultiAcnUpdate_checkEqual_str0(p1,p2) ::= "(<p1> = <p2>)"

MultiAcnUpdate_get_first_init_value_pri(sV0, sVi, bIsFirst) ::= <<
<if(bIsFirst)>if<else>elsif<endif> <sVi>_is_initialized then
    <sV0> := <sVi>;
>>

MultiAcnUpdate_get_first_init_value_str(sV0, sVi, bIsFirst) ::= <<
<MultiAcnUpdate_get_first_init_value_pri(sV0=sV0, sVi=sVi, bIsFirst=bIsFirst)>
>>

MultiAcnUpdate_checkEqual_pri(sV0, sVi) ::= "((<sVi>_is_initialized and <sV0> = <sVi>) or not <sVi>_is_initialized)"
MultiAcnUpdate_checkEqual_str(sV0, sVi) ::= "((<sVi>_is_initialized and <sV0> = <sVi>) or not <sVi>_is_initialized)"

MultiAcnUpdate(v, v0, sErrCode, arrsLocalDeclarations, arrsLocalUpdateStatements, arrsGetFirstIntValue, arrsLocalCheckEquality) ::= <<
declare
    <arrsLocalDeclarations; separator="\n">
begin
    
    <arrsLocalUpdateStatements; separator="\n">
    
    <arrsGetFirstIntValue; separator="\n"> 
    else 
        result := <rtlModuleName()>.ASN1_RESULT'(Success => False, ErrorCode => <sErrCode>);
    end if;

    result := <rtlModuleName()>.ASN1_RESULT'(Success => result.Success and (<arrsLocalCheckEquality; separator=" and ">), ErrorCode => <sErrCode>);
    <v>_is_initialized := result.Success;
end;
>>




PresenceDependency(v, sSeqPath, sAcc, sChildName) ::= <<
<v>_is_initialized := TRUE;
<v> := (<sSeqPath><sAcc>exist.<sChildName> = 1);
>>




SizeDependency(v, sCount) ::= <<
<v>_is_initialized := TRUE;
<v> := <rtlModuleName()>.Asn1UInt(<sCount>);
>>


getStringSize(p) ::= "<rtlModuleName()>.getStringSize(<p>)"
getSizeableSize(p, sAcc) ::= "<p>.Length"



ChoiceDependencyPres(sChPath, sAcc, arrsChoiceItems) ::= <<
case <sChPath><sAcc>kind IS
    <arrsChoiceItems; separator="\n">
end case;
>>

ChoiceDependencyIntPres_child(v, sChildNamePrese, nChildRetVal) ::= <<
when <sChildNamePrese> =>
    <v>_is_initialized := TRUE;
	<v> := <nChildRetVal>; 
>>

ChoiceDependencyStrPres_child(v, sChildNamePrese, sChildRetVal, arrsNullChars) ::= <<
when <sChildNamePrese> =>
    <v>_is_initialized := TRUE;
	<v> := "<sChildRetVal>"<if(arrsNullChars)> & <arrsNullChars; wrap, anchor, separator=" & "><endif>; 
>>



ChoiceDependencyEnum_Item(v, sChildCID, sEnumCName) ::= <<
when <sChildCID> =>
    <v>_is_initialized := TRUE;
	<v> := <sEnumCName>; 
>>

ChoiceDependencyEnum(sChPath, sAcc, arrsChoiceEnumItems) ::= <<
case <sChPath><sAcc>kind IS
    <arrsChoiceEnumItems; separator="\n">
end case;
>>



checkAccessPath(arrsCheckPaths, sUpdateStatement) ::= <<
if (<arrsCheckPaths; separator=" && ">) then
    <sUpdateStatement>
end if;
>>




















PrintAcn_update_param(sTasName, bHasSuccess, sParamName, sContent, sParamType, arrsTmpVars) ::= <<
PROCEDURE <sTasName>_ACN_Encode_update_<sParamName>(val : IN <sTasName>; <sParamName>: OUT <sParamType><if(bHasSuccess)>; result : OUT <rtlModuleName()>.ASN1_RESULT<endif>)
---# derives <sParamName><if(bHasSuccess)>, result<endif> from val;
IS
    <arrsTmpVars; separator="\n">
BEGIN
    <sContent>
END <sTasName>_ACN_Encode_update_<sParamName>;
>>

PrintAcn_update_param_body_choice_child(sChildName, sChildUpdateStatement, bCheckSuccess, sChildNamePresent) ::= <<
WHEN <sChildNamePresent> =>	
    <sChildUpdateStatement>
<if(!bCheckSuccess)>    result := <rtlModuleName()>.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);<endif>
>>

PrintAcn_update_param_body_choice(sTasName, arrsChildUpdateStatements) ::= <<
CASE <sTasName>_kind(val) IS
	<arrsChildUpdateStatements; separator="\n">
END CASE;
>>

PrintAcn_update_param_body(sPart, sNestedPart, bCheckSuccess) ::= <<
<sPart>
<if(sNestedPart)>
<if(bCheckSuccess)>
IF result.success THEN
    <sNestedPart>
END IF;
<else>
<sNestedPart>
<endif>
<endif>
>>



RefTypeArgument1(v, sTasName, sParamName, sRefTypePath, bHasSuccess) ::= <<
<sTasName>_ACN_Encode_update_<sParamName>(<sRefTypePath>, <v><if(bHasSuccess)>, result<endif>);
>>

RefTypeArgument2(v, sModName, sTasName, sParamName, sRefTypePath, bHasSuccess) ::= <<
<sModName>.<RefTypeArgument1(v=v, sTasName=sTasName, sParamName=sParamName, sRefTypePath=sRefTypePath, bHasSuccess=bHasSuccess)>
>>





