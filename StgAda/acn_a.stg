group a_acn;

rtlModuleName() ::= "adaasn1rtl"

EmitAcnParameter(sName, sType) ::= "<sName> : IN <sType>"

EmitTypeAssignment_def_err_code(sErrCode, nErrValue, soErrorCodeComment) ::= <<
<sErrCode>:constant Integer := <nErrValue>; <if(soErrorCodeComment)> -- <soErrorCodeComment> <endif>
>>

EmitTypeAssignment_primitive_def_encode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInACN, nMaxBitsInACN, arrsAcnPrms, soSparkAnnotations) ::= <<
<arrsErrcodes; separator="\n">
<sTypeDefName>_REQUIRED_BYTES_FOR_ACN_ENCODING:constant Integer := <nMaxBytesInACN>;
<sTypeDefName>_REQUIRED_BITS_FOR_ACN_ENCODING:constant Integer := <nMaxBitsInACN>;

<if(bEmptyEncodingSpace)>
subtype <sTypeDefName>_ACN_Stream is adaasn1rtl.encoding.Bitstream(1); -- we cannot declare a bit stream of zero size

<else>
subtype <sTypeDefName>_ACN_Stream is adaasn1rtl.encoding.Bitstream(<sTypeDefName>_REQUIRED_BYTES_FOR_ACN_ENCODING);

<endif>

procedure <sFuncName>(<sVarName> : <sTypeDefName>; Stream : out <sTypeDefName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT);

procedure <sFuncName>_aux(<sVarName> : <sTypeDefName>; bs : in out <rtlModuleName()>.encoding.Bitstream; result : OUT <rtlModuleName()>.ASN1_RESULT)
<soSparkAnnotations>
;


>>

EmitTypeAssignment_primitive_encodeMain(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitialExp, arrsAcnPrms, arrsAcnParamNames, bEmptyEncodingSpace) ::= /*nogen*/<<
procedure <sFuncName>(<sVarName> : <sTypeDefName>; Stream : out <sTypeDefName>_ACN_Stream; result : out <rtlModuleName()>.ASN1_RESULT)
is
begin
    Stream := <sTypeDefName>_ACN_Stream'(Size_In_Bytes => <if(bEmptyEncodingSpace)>1<else><sTypeDefName>_REQUIRED_BYTES_FOR_ACN_ENCODING<endif>, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    <sTypeDefName>_ACN_Encode_aux(<sVarName>, Stream, result);
end <sFuncName>;
>>

EmitTypeAssignment_primitive_encode(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitialExp, arrsAcnPrms, arrsAcnParamNames, bEmptyEncodingSpace, bBsIsUnreferenced, bVarNameIsUnreferenced, soInitFuncName, arrsAnnots, arrsPrecond, soPostcond) ::= <<
procedure <sFuncName>_aux(<sVarName> : <sTypeDefName>; bs : in out <rtlModuleName()>.encoding.Bitstream; result : OUT <rtlModuleName()>.ASN1_RESULT)
is
<if(bBsIsUnreferenced)>
pragma Unreferenced(bs);

<endif>
<if(bVarNameIsUnreferenced)>
pragma Unreferenced(<sVarName>);

<endif>
    <arrsLocalVariables; separator="\n">
begin
    <if(soIValidFuncName)>
    result := <soIValidFuncName>(<sVarName>);
    if result.success and  result.ErrorCode = 0 then
        <sContent>
    end if;
    <else>
    result := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
    <sContent>
    <endif>
end <sFuncName>_aux;
<EmitTypeAssignment_primitive_encodeMain(sVarName=sVarName, sStar=sStar, sFuncName=sFuncName, soIValidFuncName=soIValidFuncName, sTypeDefName=sTypeDefName, arrsLocalVariables=arrsLocalVariables, sContent=sContent, soSparkAnnotations=soSparkAnnotations, sInitialExp=sInitialExp, arrsAcnPrms=arrsAcnPrms, arrsAcnParamNames=arrsAcnParamNames, bEmptyEncodingSpace=bEmptyEncodingSpace)>
>>



EmitTypeAssignment_primitive_def_decode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInACN, nMaxBitsInACN, arrsAcnPrms, soSparkAnnotations) ::= <<
<arrsErrcodes; separator="\n">
procedure <sFuncName>(<sVarName>: out <sTypeDefName>; Stream : in out <sTypeDefName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsAcnPrms)>; <arrsAcnPrms; separator="; "><endif>);

procedure <sFuncName>_aux(<sVarName>:out <sTypeDefName>; bs : in out <rtlModuleName()>.encoding.Bitstream; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsAcnPrms)>; <arrsAcnPrms; separator="; "><endif>)
<soSparkAnnotations>
;
>>

EmitTypeAssignment_primitive_decodeMain(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitialExp, arrsAcnPrms, arrsAcnParamNames, bEmptyEncodingSpace) ::= /*nogen*/<<
PROCEDURE <sFuncName>(<sVarName>: out <sTypeDefName>; Stream : in out <sTypeDefName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsAcnPrms)>; <arrsAcnPrms; separator="; "><endif>)
is
begin
    Stream.Current_Bit_Pos :=0;
    <sFuncName>_aux(<sVarName>, Stream, result<if(arrsAcnParamNames)>, <arrsAcnParamNames; separator=","><endif>);
    <if(soIValidFuncName)>
    if result.success then
        result := <soIValidFuncName>(<sVarName>);
    end if;

    <endif>
end <sFuncName>;
>>

EmitTypeAssignment_primitive_decode(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitialExp, arrsAcnPrms, arrsAcnParamNames, bEmptyEncodingSpace, bBsIsUnreferenced, bVarNameIsUnreferenced, soInitFuncName, arrsAnnots, arrsPrecond, soPostcond) ::= <<
<if(bVarNameIsUnreferenced)>
pragma Warnings (Off, "unused initial value of ""<sVarName>""");

<endif>

procedure <sFuncName>_aux(<sVarName>:out <sTypeDefName>; bs : in out <rtlModuleName()>.encoding.Bitstream; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsAcnPrms)>; <arrsAcnPrms; separator="; "><endif>)
is
<if(bBsIsUnreferenced)>
pragma Unreferenced(bs);

<endif>
    <arrsLocalVariables; separator="\n">
begin
    <sContent>
end <sFuncName>_aux;
<if(bVarNameIsUnreferenced)>
pragma Warnings (On, "unused initial value of ""<sVarName>""");

<endif>

<EmitTypeAssignment_primitive_decodeMain(sVarName=sVarName, sStar=sStar, sFuncName=sFuncName, soIValidFuncName=soIValidFuncName, sTypeDefName=sTypeDefName, arrsLocalVariables=arrsLocalVariables, sContent=sContent, soSparkAnnotations=soSparkAnnotations, sInitialExp=sInitialExp, arrsAcnPrms=arrsAcnPrms, arrsAcnParamNames=arrsAcnParamNames, bEmptyEncodingSpace=bEmptyEncodingSpace)>
>>


sparkAnnotations_encode(sTypeDefName) ::= <<
with
    Pre => bs.Current_Bit_Pos \< Natural'Last - <sTypeDefName>_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes \< Positive'Last / 8
      and then bs.Current_Bit_Pos + <sTypeDefName>_REQUIRED_BITS_FOR_ACN_ENCODING \<= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos \>= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos \<= bs'Old.Current_Bit_Pos + <sTypeDefName>_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
>>

sparkAnnotations_decode(sTypeDefName) ::= <<
with
    Pre => bs.Current_Bit_Pos \< Natural'Last - <sTypeDefName>_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes \< Positive'Last / 8
      and then bs.Current_Bit_Pos + <sTypeDefName>_REQUIRED_BITS_FOR_ACN_ENCODING \<= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos \>= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos \<= bs'Old.Current_Bit_Pos + <sTypeDefName>_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
>>



MF(p, soMF, soMFM, nUperMin, nUperMax) ::= /*nogen*/ <<
if Result.Success then
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
    Result.Success := <p> \>= <nUperMin> AND <p> \<= <nUperMax>;
    if NOT Result.Success then
        <p> := <nUperMin>;							-- COVERAGE_IGNORE
        Result.ErrorCode := ERR_INCORRECT_STREAM;	-- COVERAGE_IGNORE
    end if;
end if;
>>

MFen(soMF, soMFM, p) /*nogen*/ ::= "<if(soMF)><soMFM>.<soMF>_encode(<p>)<else><p><endif>"


alignToNext_encode(sMainBody, sAlignmentValue, nAlignmentValue, nAbsOffset, nRemainingMinBits, nLevel, nIx, nOffset) ::= <<
--align to next <sAlignmentValue>
if (bs.Current_Bit_Pos mod <nAlignmentValue>) /= 0 then
    bs.Current_Bit_Pos := bs.Current_Bit_Pos + (<nAlignmentValue> - (bs.Current_Bit_Pos mod <nAlignmentValue>));
end if;
<sMainBody>
>>


alignToNext_decode(sMainBody, sAlignmentValue, nAlignmentValue, nAbsOffset, nRemainingMinBits, nLevel, nIx, nOffset) ::= <<
--align to next <sAlignmentValue>
if (bs.Current_Bit_Pos mod <nAlignmentValue>) /= 0 then
    bs.Current_Bit_Pos := bs.Current_Bit_Pos + (<nAlignmentValue> - (bs.Current_Bit_Pos mod <nAlignmentValue>));
end if;
<sMainBody>
>>


PositiveInteger_ConstSize_encode(p, sSsuffix, sErrCode, nFixedSize, soMF, soMFM, nUperMin, nUperMax) ::= <<
adaasn1rtl.encoding.acn.Acn_Enc_Int_PositiveInteger_ConstSize(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nFixedSize>);
>>

PositiveInteger_ConstSize_decode(p, sSsuffix, sErrCode, nFixedSize, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize<sSsuffix>(bs, mapFuncIntVal, 0, 0, Asn1Int(2)**<nFixedSize> - 1, <nFixedSize>, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, <nFixedSize>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_ConstSize_8_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_PositiveInteger_ConstSize_8(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_8_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_8<sSsuffix>(bs, mapFuncIntVal, 0, 0, Asn1Int(255), result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_8<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_ConstSize_big_endian_16_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_big_endian_16_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16<sSsuffix>(bs, mapFuncIntVal, 0, 0, Asn1Int(65535), result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>


PositiveInteger_ConstSize_big_endian_32_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_big_endian_32_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32<sSsuffix>(bs, mapFuncIntVal, 0, 0, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_ConstSize_big_endian_64_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_64(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_big_endian_64_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64<sSsuffix>(bs, mapFuncIntVal, 0, 0, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_ConstSize_little_endian_16_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_16(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_little_endian_16_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16<sSsuffix>(bs, mapFuncIntVal, 0, 0, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_ConstSize_little_endian_32_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_little_endian_32_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32<sSsuffix>(bs, mapFuncIntVal, 0, 0, Asn1Int'Last,  result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>,  result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_ConstSize_little_endian_64_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_64(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_little_endian_64_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64<sSsuffix>(bs, mapFuncIntVal, 0, 0, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

PositiveInteger_VarSize_LengthEmbedded_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_PositiveInteger_VarSize_LengthEmbedded(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_VarSize_LengthEmbedded_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_VarSize_LengthEmbedded<sSsuffix>(bs, mapFuncIntVal, 0, 0, result);
if Result.Success then
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
    Result.Success := <p> \>= <nUperMin>;
    if NOT Result.Success then
        <p> := <nUperMin>;					-- COVERAGE_IGNORE
        result.ErrorCode := <sErrCode>;		-- COVERAGE_IGNORE
    end if;
end if;

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_VarSize_LengthEmbedded<sSsuffix>(bs, <p>, <nUperMin>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>


TwosComplement_ConstSize_encode(p, sSsuffix, sErrCode, soMF, soMFM, nFixedSize, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_TwosComplement_ConstSize(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nFixedSize>);"
TwosComplement_ConstSize_decode(p, sSsuffix, sErrCode, soMF, soMFM, nFixedSize, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize<sSsuffix>(bs, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, <nFixedSize>, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, <nFixedSize>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_8_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_TwosComplement_ConstSize_8(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_8_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_8<sSsuffix>(bs, mapFuncIntVal, -Asn1Int(128), Asn1Int(127), result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_8<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_big_endian_16_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_TwosComplement_ConstSize_big_endian_16(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_big_endian_16_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_16<sSsuffix>(bs, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_16<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_big_endian_32_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_TwosComplement_ConstSize_big_endian_32(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_big_endian_32_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_32<sSsuffix>(bs, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_32<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_big_endian_64_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_TwosComplement_ConstSize_big_endian_64(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_big_endian_64_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_64<sSsuffix>(bs, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_64<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_little_endian_16_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_TwosComplement_ConstSize_little_endian_16(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_little_endian_16_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_16<sSsuffix>(bs, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_16<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_little_endian_32_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_TwosComplement_ConstSize_little_endian_32(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_little_endian_32_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_32<sSsuffix>(bs, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_32<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_ConstSize_little_endian_64_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_TwosComplement_ConstSize_little_endian_64(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_little_endian_64_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_64<sSsuffix>(bs, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_64<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

TwosComplement_VarSize_LengthEmbedded_encode(p, sSsuffix, sErrCode, soMF, soMFM) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_TwosComplement_VarSize_LengthEmbedded(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_VarSize_LengthEmbedded_decode(p, sSsuffix, sErrCode, soMF, soMFM) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_VarSize_LengthEmbedded<sSsuffix>(bs, <p>, result);
result.ErrorCode := <sErrCode>;
if Result.Success then
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
end if;

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_TwosComplement_VarSize_LengthEmbedded<sSsuffix>(bs, <p>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>


BCD_ConstSize_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, nNibbles) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_BCD_ConstSize(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nNibbles>);"
BCD_ConstSize_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, nNibbles) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_BCD_ConstSize<sSsuffix>(bs, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, <nNibbles>, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_BCD_ConstSize<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, <nNibbles>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

BCD_VarSize_LengthEmbedded_encode(p, sSsuffix, sErrCode, soMF, soMFM) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_BCD_VarSize_LengthEmbedded(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
BCD_VarSize_LengthEmbedded_decode(p, sSsuffix, sErrCode, soMF, soMFM) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_BCD_VarSize_LengthEmbedded<sSsuffix>(bs, mapFuncIntVal, result);
result.ErrorCode := <sErrCode>;
if Result.Success then
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
end if;

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_BCD_VarSize_LengthEmbedded<sSsuffix>(bs, <p>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

BCD_VarSize_NullTerminated_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_BCD_VarSize_NullTerminated(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
BCD_VarSize_NullTerminated_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_BCD_VarSize_NullTerminated<sSsuffix>(bs, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_BCD_VarSize_NullTerminated<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

ASCII_ConstSize_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_ASCII_ConstSize(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nSizeInBytes>);"
ASCII_ConstSize_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_ASCII_ConstSize<sSsuffix>(bs, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, <nSizeInBytes>, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_ASCII_ConstSize<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, <nSizeInBytes>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>


ASCII_UINT_ConstSize_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= "adaasn1rtl.encoding.acn.Acn_Enc_UInt_ASCII_ConstSize(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nSizeInBytes>);"
ASCII_UINT_ConstSize_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_UInt_ASCII_ConstSize<sSsuffix>(bs, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, <nSizeInBytes>, result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_UInt_ASCII_ConstSize<sSsuffix>(bs, <p>, <nUperMin>, <nUperMax>, <nSizeInBytes>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>



ASCII_VarSize_LengthEmbedded_encode(p, sSsuffix, sErrCode, soMF, soMFM) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_ASCII_VarSize_LengthEmbedded(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
ASCII_VarSize_LengthEmbedded_decode(p, sSsuffix, sErrCode, soMF, soMFM) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_ASCII_VarSize_LengthEmbedded<sSsuffix>(bs, mapFuncIntVal, result);
result.ErrorCode := <sErrCode>;
if Result.Success then
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
end if;

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_ASCII_VarSize_LengthEmbedded<sSsuffix>(bs, <p>, result);
result.ErrorCode := <sErrCode>;

<endif>
>>

ASCII_VarSize_NullTerminated_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, arruNullBytes) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Int_ASCII_VarSize_NullTerminated(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, adaasn1rtl.OctetBuffer'(<arruNullBytes : {b|<i>=><b>}; separator=\", \">));"
ASCII_VarSize_NullTerminated_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, arruNullBytes) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_Int_ASCII_VarSize_NullTerminated<sSsuffix>(bs, mapFuncIntVal, adaasn1rtl.OctetBuffer'(<arruNullBytes : {b|<i>=><b>}; separator=", ">), result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Int_ASCII_VarSize_NullTerminated<sSsuffix>(bs, <p>, adaasn1rtl.OctetBuffer'(<arruNullBytes : {b|<i>=><b>}; separator=", ">), result);
result.ErrorCode := <sErrCode>;

<endif>
>>


ASCII_UINT_VarSize_NullTerminated_encode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, arruNullBytes) ::= "adaasn1rtl.encoding.acn.Acn_Enc_UInt_ASCII_VarSize_NullTerminated(bs, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, adaasn1rtl.OctetBuffer'(<arruNullBytes : {b|<i>=><b>}; separator=\", \">));"
ASCII_UINT_VarSize_NullTerminated_decode(p, sSsuffix, sErrCode, soMF, soMFM, nUperMin, nUperMax, arruNullBytes) ::= <<
<if(soMF)>
adaasn1rtl.encoding.acn.Acn_Dec_UInt_ASCII_VarSize_NullTerminated<sSsuffix>(bs, mapFuncIntVal, adaasn1rtl.OctetBuffer'(<arruNullBytes : {b|<i>=><b>}; separator=", ">), result);
result.ErrorCode := <sErrCode>;
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
adaasn1rtl.encoding.acn.Acn_Dec_UInt_ASCII_VarSize_NullTerminated<sSsuffix>(bs, <p>, adaasn1rtl.OctetBuffer'(<arruNullBytes : {b|<i>=><b>}; separator=", ">), result);
result.ErrorCode := <sErrCode>;

<endif>
>>


/************************ OLD macros ***********************************************************************/





Real_32_big_endian_encode(p, sSuffix, sErrCode) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Real_IEEE754_32_big_endian(bs, <p>);"
Real_32_big_endian_decode(p, sSuffix, sErrCode) ::= <<
adaasn1rtl.encoding.acn.Acn_Dec_Real_IEEE754_32_big_endian<sSuffix>(bs, <p>, result);
result.ErrorCode := <sErrCode>;
>>

Real_64_big_endian_encode(p, sErrCode) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Real_IEEE754_64_big_endian(bs, <p>);"
Real_64_big_endian_decode(p, sErrCode) ::= <<
adaasn1rtl.encoding.acn.Acn_Dec_Real_IEEE754_64_big_endian(bs, <p>, result);
result.ErrorCode := <sErrCode>;
>>

Real_32_little_endian_encode(p, sSuffix, sErrCode) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Real_IEEE754_32_little_endian(bs, <p>);"
Real_32_little_endian_decode(p, sSuffix, sErrCode) ::= <<
adaasn1rtl.encoding.acn.Acn_Dec_Real_IEEE754_32_little_endian<sSuffix>(bs, <p>, result);
result.ErrorCode := <sErrCode>;
>>

Real_64_little_endian_encode(p, sErrCode) ::= "adaasn1rtl.encoding.acn.Acn_Enc_Real_IEEE754_64_little_endian(bs, <p>);"
Real_64_little_endian_decode(p, sErrCode) ::= <<
adaasn1rtl.encoding.acn.Acn_Dec_Real_IEEE754_64_little_endian(bs, <p>, result);
result.ErrorCode := <sErrCode>;
>>




Boolean_encode(p, ptr, bTruePattern, nSize, arruTrueValueAsByteArray, arruFalseValueAsByteArray, arrsBits, sErrCode) ::= <<
<if(bTruePattern)>
adaasn1rtl.encoding.acn.Acn_Enc_Boolean_true_pattern(bs, <p>, BitArray'(<arrsBits; separator=",">));

<else>
adaasn1rtl.encoding.acn.Acn_Enc_Boolean_false_pattern(bs, <p>, BitArray'(<arrsBits; separator=",">));

<endif>
>>

Boolean_decode(p, ptr, bTruePattern, nSize, arruTrueValueAsByteArray, arruFalseValueAsByteArray, arrsBits, sErrCode) ::= <<
<if(bTruePattern)>
adaasn1rtl.encoding.acn.Acn_Dec_Boolean_true_pattern(bs, <p>, BitArray'(<arrsBits; separator=",">), result);

<else>
adaasn1rtl.encoding.acn.Acn_Dec_Boolean_false_pattern(bs, <p>, BitArray'(<arrsBits; separator=",">), result);

<endif>
result.ErrorCode := <sErrCode>;
>>

BooleanTrueFalse_encode(p, ptr, nSize, arruTrueValueAsByteArray, arruFalseValueAsByteArray, arrsTrueBits, arrsFalseBits,  sErrCode) ::= <<
adaasn1rtl.encoding.acn.Acn_Enc_Boolean_true_false_pattern(bs, <p>, BitArray'(<arrsTrueBits; separator=",">), BitArray'(<arrsFalseBits; separator=",">));
>>

BooleanTrueFalse_decode(p, ptr, nSize, arruTrueValueAsByteArray, arruFalseValueAsByteArray, arrsTrueBits, arrsFalseBits, sErrCode) ::= <<
adaasn1rtl.encoding.acn.Acn_Dec_Boolean_true_false_pattern(bs, <p>, BitArray'(<arrsTrueBits; separator=",">), BitArray'(<arrsFalseBits; separator=",">), result);
result.ErrorCode := <sErrCode>;
>>

Null_declare(p) ::= ""

Null_pattern_encode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode, bSavePosition) ::= <<
adaasn1rtl.encoding.acn.Acn_Enc_NullType_pattern(bs, <p>, BitArray'(<arrsBits; separator=",">));
>>

Null_pattern_decode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode, bSavePosition) ::= <<
<if(bSavePosition)>
result.ErrorCode := <sErrCode>;
result.Success := True;
bs.Current_Bit_Pos := bs.Current_Bit_Pos + <nSize>;

<else>
adaasn1rtl.encoding.acn.Acn_Dec_NullType_pattern(bs, <p>, BitArray'(<arrsBits; separator=",">), result);
result.ErrorCode := <sErrCode>;

<endif>
>>



Null_pattern2_encode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode, bSavePosition) ::= <<
adaasn1rtl.encoding.acn.Acn_Enc_NullType_pattern2(bs, BitArray'(<arrsBits; separator=",">));
>>

Null_pattern2_decode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode, bSavePosition) ::= <<
<if(bSavePosition)>
result.ErrorCode := <sErrCode>;
result.Success := True;
bs.Current_Bit_Pos := bs.Current_Bit_Pos + <nSize>;

<else>
adaasn1rtl.encoding.acn.Acn_Dec_NullType_pattern2(bs, BitArray'(<arrsBits; separator=",">), result);
result.ErrorCode := <sErrCode>;

<endif>
>>








Enumerated_item_encode(p, sName, sEnumHolder, nItemIdx, sItemVal, sIntVal) ::= "when <sName>    => <sIntVal> := <sItemVal>;"

Enumerated_item_decode(p, sName, sEnumHolder, nItemIdx, sItemVal, sIntVal) ::= "when <nItemIdx> => <p> := <sName>;"

EnumeratedEncIdx_encode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, sActualCodecFunc, sIntVal) ::= <<
case <p> is
    <arrsItem; separator="\n">
end case;
<sActualCodecFunc>
>>

EnumeratedEncIdx_decode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, sActualCodecFunc, sIntVal) ::= <<
<p> := <td.typeName>_Init;
<sActualCodecFunc>
if result.Success then
    case <td.index_range>(<sIntVal>) is
        <arrsItem; separator="\n">
    end case;
end if;
>>


EnumeratedEncValues_encode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, sActualCodecFunc, sErrCode, sFirstItemName, sIntVal) ::= <<
<EnumeratedEncIdx_encode(p=p, td=td, arrsItem=arrsItem, sActualCodecFunc=sActualCodecFunc)>
>>

EnumeratedEncValues_decode(p, td/*:FE_EnumeratedTypeDefinition*/, arrsItem, sActualCodecFunc, sErrCode, sFirstItemName, sIntVal) ::= <<
<sActualCodecFunc>
if result.Success then
    case <sIntVal> is
        <arrsItem; separator="\n">
    when others =>																				-- COVERAGE_IGNORE
        <p> := <sFirstItemName>;																-- COVERAGE_IGNORE
        result := <rtlModuleName()>.ASN1_RESULT'(Success => False, ErrorCode => <sErrCode>);	-- COVERAGE_IGNORE
    end case;
else
    <p> := <sFirstItemName>;																	-- COVERAGE_IGNORE
    result.ErrorCode := <sErrCode>;																-- COVERAGE_IGNORE
end if;
>>

EnumeratedEncValues_no_switch_encode(p, td/*:FE_EnumeratedTypeDefinition*/, sActualCodecFunc, sErrCode, sFirstItemName, sIntVal, sEnumIndex, nLastItemIndex, bEncodeValues) ::= <<
>>

EnumeratedEncValues_no_switch_decode(p, td/*:FE_EnumeratedTypeDefinition*/, sActualCodecFunc, sErrCode, sFirstItemName, sIntVal, sEnumIndex, nLastItemIndex, bEncodeValues) ::= <<
>>

// Strings



Acn_String_Ascii_FixSize_encode(p, sErrCode, nAsn1Max) ::= "adaasn1rtl.encoding.acn.Acn_Enc_String_Ascii_FixSize(bs, <p>);"
Acn_String_Ascii_FixSize_decode(p, sErrCode, nAsn1Max) ::= <<
adaasn1rtl.encoding.acn.Acn_Dec_String_Ascii_FixSize(bs, <p>, result);
result.ErrorCode := <sErrCode>;
>>

Acn_String_Ascii_Null_Terminated_encode(p, sErrCode, nAsn1Max, arruNullBytes) ::= "adaasn1rtl.encoding.acn.Acn_Enc_String_Ascii_Null_Terminated(bs, adaasn1rtl.OctetBuffer'(<arruNullBytes : {b|<i>=><b>}; separator=\", \">), <p>);"
Acn_String_Ascii_Null_Terminated_decode(p, sErrCode, nAsn1Max, arruNullBytes) ::= <<
adaasn1rtl.encoding.acn.Acn_Dec_String_Ascii_Null_Terminated(bs, adaasn1rtl.OctetBuffer'(<arruNullBytes : {b|<i>=><b>}; separator=", ">), <p>, result);
result.ErrorCode := <sErrCode>;
>>


Acn_String_Ascii_External_Field_Determinant_encode(p, sErrCode, nAsn1Max, sExtFld) ::= "adaasn1rtl.encoding.acn.Acn_Enc_String_Ascii_External_Field_Determinant(bs, <p>);"
Acn_String_Ascii_External_Field_Determinant_decode(p, sErrCode, nAsn1Max, sExtFld) ::= <<
adaasn1rtl.encoding.acn.Acn_Dec_String_Ascii_External_Field_Determinant(bs, <rtlModuleName()>.Asn1Int(<sExtFld>), <p>, result);
result.ErrorCode := <sErrCode>;
>>


Acn_String_Ascii_Internal_Field_Determinant_encode(p, sErrCode, nAsn1Max, nAsn1Min, nInternalLengthDeterminantSizeInBits) ::= <<
result.ErrorCode := <sErrCode>;
result.Success := <nAsn1Min> \<= <rtlModuleName()>.getStringSize(<p>);
if result.Success then
    adaasn1rtl.encoding.acn.Acn_Enc_String_Ascii_Internal_Field_Determinant(bs, <nAsn1Min>, <nInternalLengthDeterminantSizeInBits>, <p>);
end if;
>>
Acn_String_Ascii_Internal_Field_Determinant_decode(p, sErrCode, nAsn1Max, nAsn1Min, nInternalLengthDeterminantSizeInBits) ::= <<
adaasn1rtl.encoding.acn.Acn_Dec_String_Ascii_Internal_Field_Determinant(bs, <nAsn1Min>, <nAsn1Max>, <nInternalLengthDeterminantSizeInBits>, <p>, result);
result.ErrorCode := <sErrCode>;
>>



Acn_String_CharIndex_FixSize_encode(p, sErrCode, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, td/*:FE_StringTypeDefinition*/, nCharSize) ::= "adaasn1rtl.encoding.acn.Acn_Enc_String_CharIndex_FixSize(bs, <td.alpha_set>, <nCharSize>, <p>);"
Acn_String_CharIndex_FixSize_decode(p, sErrCode, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, td/*:FE_StringTypeDefinition*/, nCharSize) ::= <<
adaasn1rtl.encoding.acn.Acn_Dec_String_CharIndex_FixSize(bs, <td.alpha_set>, <nCharSize>, <p>, result);
result.ErrorCode := <sErrCode>;
>>


Acn_String_CharIndex_External_Field_Determinant_encode(p, sErrCode, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, sExtFld, td/*:FE_StringTypeDefinition*/, nCharSize) ::= "adaasn1rtl.encoding.acn.Acn_Enc_String_CharIndex_External_Field_Determinant(bs, <td.alpha_set>, <nCharSize>, <p>);"
Acn_String_CharIndex_External_Field_Determinant_decode(p, sErrCode, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, sExtFld, td/*:FE_StringTypeDefinition*/, nCharSize) ::= <<
adaasn1rtl.encoding.acn.Acn_Dec_String_CharIndex_External_Field_Determinant(bs, <td.alpha_set>, <nCharSize>, <rtlModuleName()>.Asn1Int(<sExtFld>), <p>, result);
result.ErrorCode := <sErrCode>;
>>


Acn_IA5String_CharIndex_External_Field_Determinant_encode(p, sErrCode, nAsn1Max, sExtFld, td/*:FE_StringTypeDefinition*/, nCharSize, nRemainingBits) ::= "adaasn1rtl.encoding.acn.Acn_Enc_String_CharIndex_External_Field_Determinant(bs, <td.alpha_set>, <nCharSize>, <p>);"
Acn_IA5String_CharIndex_External_Field_Determinant_decode(p, sErrCode, nAsn1Max, sExtFld, td/*:FE_StringTypeDefinition*/, nCharSize, nRemainingBits) ::= <<
adaasn1rtl.encoding.acn.Acn_Dec_String_CharIndex_External_Field_Determinant(bs, <td.alpha_set>, <nCharSize>, <rtlModuleName()>.Asn1Int(<sExtFld>), <p>, result);
result.ErrorCode := <sErrCode>;
>>









loopFixedItem_enc (i, fixedSize, nfixedSizeUperLimit, sInternalItem, nCurOffset, nAlignSize, nIntItemMinSize, nIntItemMaxSize)::= /*nogen*/<<
<i> := 1;
while <i>\<= <fixedSize> loop
    pragma Loop_Invariant (<i> >=1 and <i>\<=<fixedSize>);
    pragma Loop_Invariant (bs.Current_Bit_Pos \>= bs.Current_Bit_Pos'Loop_Entry);
    pragma Loop_Invariant (bs.Current_Bit_Pos\<=bs.Current_Bit_Pos'Loop_Entry + <nIntItemMaxSize>*(<i>-1));
    <sInternalItem>
    <i> := <i> + 1;
end loop;
>>

loopFixedItem_dec (i, fixedSize, nfixedSizeUperLimit, sInternalItem, nCurOffset, nAlignSize, nIntItemMinSize, nIntItemMaxSize)::= /*nogen*/<<
<i> := 1;
while <i>\<= <fixedSize> AND result.Success loop
    pragma Loop_Invariant (<i> >=1 and <i>\<=<fixedSize>);
    pragma Loop_Invariant (bs.Current_Bit_Pos \>= bs.Current_Bit_Pos'Loop_Entry);
    pragma Loop_Invariant (bs.Current_Bit_Pos\<=bs.Current_Bit_Pos'Loop_Entry + <nIntItemMaxSize>*(<i>-1));
    <sInternalItem>
    <i> := <i> + 1;
end loop;
>>



/* Strings */






seqOf_VarSize_encode(p, sAcc, sTasName, i, sInternalItem, nSizeMin, nSizeMax, nSizeInBits, nIntItemMinSize, nIntItemMaxSize, nAlignSize, sChildInitExpr, sErrCode, nAbsOffset, nRemainingMinBits, nLevel, nIx, nOffset, bIntroSnap, soCallAux) ::= <<
result.Success := <p><sAcc>Length >= <nSizeMin> AND <p><sAcc>Length \<= <nSizeMax>;
result.errorCode := <sErrCode>;
if result.Success then
    adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, <rtlModuleName()>.Asn1Int(<p><sAcc>Length), <nSizeMin>, <nSizeInBits>);
    <loopFixedItem_enc(i=i, sInternalItem=sInternalItem, fixedSize=[p, sAcc, "Length"], nfixedSizeUperLimit = nSizeMax, nCurOffset=nSizeInBits, nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
end if;
>>

seqOf_VarSize_decode(p, sAcc, sTasName, i, sInternalItem, nSizeMin, nSizeMax, nSizeInBits, nIntItemMinSize, nIntItemMaxSize, nAlignSize, sChildInitExpr, sErrCode, nAbsOffset, nRemainingMinBits, nLevel, nIx, nOffset, bIntroSnap, soCallAux) ::= <<
adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumberInt(bs, nStringLength, <nSizeMin>, <nSizeMax>, <nSizeInBits>, result.Success);
result.errorCode := <sErrCode>;
<p>.Length := nStringLength;
<loopFixedItem_dec(i=i, sInternalItem=sInternalItem, fixedSize=[p, sAcc, "Length"], nfixedSizeUperLimit = nSizeMax, nCurOffset=nSizeInBits, nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
>>

sqf_external_field_encode(sTypeDefName, p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, sExtFld, bIsUnsigned, nAlignSize, sErrCode, nIntItemMinSize, nIntItemMaxSize, sChildInitExpr, bIntroSnap, soCallAux) ::= <<
<loopFixedItem_enc(i=i, sInternalItem=sInternalItem, fixedSize=[p,".Length"], nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
>>


sqf_external_field_decode(sTypeDefName, p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, sExtFld, bIsUnsigned, nAlignSize, sErrCode, nIntItemMinSize, nIntItemMaxSize, sChildInitExpr, bIntroSnap, soCallAux) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <if(noSizeMin)><noSizeMin>\<=<sExtFld> AND <endif><sExtFld>\<=<nSizeMax>, ErrorCode => <sErrCode>);
if result.Success then
    <p>.Length := Integer(<sExtFld>);
    <loopFixedItem_dec(i=i, sInternalItem=sInternalItem, fixedSize=[p,".Length"], nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
end if;
>>


sqf_external_field_fix_size_encode(sTypeDefName, p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, sExtFld, bIsUnsigned, nAlignSize, sErrCode, nIntItemMinSize, nIntItemMaxSize, sChildInitExpr, bIntroSnap, soCallAux) ::= <<
<loopFixedItem_enc(i=i, sInternalItem=sInternalItem, fixedSize=[nSizeMax], nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
>>


sqf_external_field_fix_size_decode(sTypeDefName, p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, sExtFld, bIsUnsigned, nAlignSize, sErrCode, nIntItemMinSize, nIntItemMaxSize, sChildInitExpr, bIntroSnap, soCallAux) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <if(noSizeMin)><noSizeMin>\<=<sExtFld> AND <endif><sExtFld>\<=<nSizeMax>, ErrorCode => <sErrCode>);
if result.Success then
    <loopFixedItem_dec(i=i, sInternalItem=sInternalItem, fixedSize=[nSizeMax], nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
end if;
>>


oct_sqf_null_terminated_encode(p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, arruNullBytes, nBitPatternLength, sErrCode, nIntItemMinSize, nIntItemMaxSize) ::= <<
<loopFixedItem_enc(i=i, sInternalItem=sInternalItem, fixedSize=[p,".Length"], nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize="", nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
<rtlModuleName()>.encoding.BitStream_AppendBits(bs, <rtlModuleName()>.OctetBuffer'(<arruNullBytes:{b|<i>=>16#<b;format="X2">#}; wrap, anchor, separator=", ">), <nBitPatternLength>);
>>

oct_sqf_null_terminated_decode(p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, arruNullBytes, nBitPatternLength, sErrCode, nIntItemMinSize, nIntItemMaxSize) ::= <<
<i> := 1;
result := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
while result.Success and then <i>\<= <nSizeMax> and then not <rtlModuleName()>.encoding.BitStream_bitPatternMatches(bs,<rtlModuleName()>.OctetBuffer'(<arruNullBytes:{b|<i>=>16#<b;format="X2">#}; wrap, anchor, separator=", ">), <nBitPatternLength>)  loop
    pragma Loop_Invariant (<i> >=1 and <i>\<=<nSizeMax>);
    pragma Loop_Invariant (bs.Current_Bit_Pos \>= bs.Current_Bit_Pos'Loop_Entry);
    pragma Loop_Invariant (bs.Current_Bit_Pos\<=bs.Current_Bit_Pos'Loop_Entry + <nIntItemMaxSize>*(<i>-1));
    <sInternalItem>
    <i> := <i> + 1;
end loop;

if result.Success and <i> = <nSizeMax>+1  then
	-- maximum number of elements was decoded. Makesure that the following bits is the termination pattern
	result.Success := <rtlModuleName()>.encoding.BitStream_bitPatternMatches(bs,<rtlModuleName()>.OctetBuffer'(<arruNullBytes:{b|<i>=>16#<b;format="X2">#}; wrap, anchor, separator=", ">), <nBitPatternLength>);
	if result.Success then
		<rtlModuleName()>.encoding.BitStream_SkipBits(bs, <nBitPatternLength>);
		<p>.Length := <i>-1;
	end if;
	result := <rtlModuleName()>.ASN1_RESULT'(Success => result.Success, ErrorCode => <sErrCode>);
elsif result.Success and <i> \< <nSizeMax>+1 then
	<p>.Length := <i>-1;
	<rtlModuleName()>.encoding.BitStream_SkipBits(bs, <nBitPatternLength>);
	result := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
else
	result := <rtlModuleName()>.ASN1_RESULT'(Success => false, ErrorCode => <sErrCode>); --COVERAGE_IGNORE
end if;
>>




RefTypeParam_tmpVar(sName, sTypeDecl) ::= "<sName>:<sTypeDecl>;"

ReferenceType1_encode(p, sName, bAcnEncodeFuncRequiresResult, arrsArgs, arrsLocalPrms) ::= <<
<arrsLocalPrms, arrsArgs: {lp,arg|<if(arg)><lp> := <arg>;-- 3031<endif>}; separator="\n">
<sName>_ACN_Encode(<p>, bs<if(bAcnEncodeFuncRequiresResult)>, result<endif><if(arrsArgs)>, <arrsLocalPrms; separator=", "><endif>);
>>

ReferenceType1_decode(p, sName, bAcnEncodeFuncRequiresResult, arrsArgs, arrsLocalPrms) ::= <<
<arrsLocalPrms, arrsArgs: {lp,arg|<if(arg)><lp> := <arg>; -- 3030<endif>}; separator="\n">
<sName>_ACN_Decode(<p>, bs, result<if(arrsArgs)>, <arrsLocalPrms; separator=", "><endif>);
>>



/* SEQUENCE*/

sequence_presence_optChild_encode(p, sAcc, sChName, soExistVar, sErrCode) ::= "<rtlModuleName()>.encoding.BitStream_AppendBit(bs,<p>.Exist.<sChName>);"
sequence_presence_optChild_decode(p, sAcc, sChName, soExistVar, sErrCode) ::= <<
result.ErrorCode := <sErrCode>;
<rtlModuleName()>.encoding.BitStream_ReadBit(bs, <soExistVar>, result.Success);
<p>.Exist.<sChName> := <soExistVar>;
>>

sequence_presence_optChild_pres_acn_expression_encode(p, sAcc, sChName, sAcnExpression, soExistVar, sErrCode) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <p>.Exist.<sChName> = (if (<sAcnExpression>) then 1 else 0), ErrorCode => <sErrCode>);
>>
sequence_presence_optChild_pres_acn_expression_decode(p, sAcc, sChName, sAcnExpression, soExistVar, sErrCode) ::= <<
<soExistVar> := (if (<sAcnExpression>) then 1 else 0);
<p>.Exist.<sChName> := <soExistVar>;
result.Success := true;
>>


sequence_presence_optChild_pres_bool_encode(p, sAcc, sChName, sExtFldName) ::= ""
sequence_presence_optChild_pres_bool_decode(p, sAcc, sChName, sExtFldName) ::= <<
<p>.Exist.<sChName> := (if <sExtFldName> then 1 else 0);
result.Success := true;
>>

sequence_presence_optChild_pres_int_encode(p, sAcc, sChName, sExtFldName, nIntVal) ::= ""
sequence_presence_optChild_pres_int_decode(p, sAcc, sChName, sExtFldName, nIntVal) ::= <<
<p>.Exist.<sChName> := (if <sExtFldName> = <nIntVal> then 1 else 0);
result.Success := true;
>>

sequence_presence_optChild_pres_str_encode(p, sAcc, sChName, sExtFldName, sVal) ::= ""
sequence_presence_optChild_pres_str_decode(p, sAcc, sChName, sExtFldName, sVal) ::= <<
<p>.Exist.<sChName> := (if <sExtFldName> = "<nIntVal>" then 1 else 0);
result.Success := true;
>>

sequence_save_bitStream_start_encode(sBitStreamPositionsLocalVar) ::=<<
<sBitStreamPositionsLocalVar>.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
<sBitStreamPositionsLocalVar>.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
>>

sequence_save_bitStream_start_decode(sBitStreamPositionsLocalVar) ::=<<
result.Success := True;
<sBitStreamPositionsLocalVar>.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
<sBitStreamPositionsLocalVar>.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
>>


sequence_save_bitstream_encode(sBitStreamPositionsLocalVar, sChName) ::=<<
<sBitStreamPositionsLocalVar>.<sChName>.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
<sBitStreamPositionsLocalVar>.<sChName>.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
>>

sequence_save_bitstream_decode(sBitStreamPositionsLocalVar, sChName) ::=<<
<sBitStreamPositionsLocalVar>.<sChName>.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
<sBitStreamPositionsLocalVar>.<sChName>.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
>>


sequence_acn_child_encode(sChName, sChildContent, sErrCode, soSaveBitStrmPosStatement) ::= <<
--Encode <sChName>
if <sChName>_is_initialized then
    result := <rtlModuleName()>.ASN1_RESULT'(Success => True, ErrorCode => 0);
    <soSaveBitStrmPosStatement>
    <sChildContent>
else
    result := <rtlModuleName()>.ASN1_RESULT'(Success => False, ErrorCode => <sErrCode>); --COVERAGE_IGNORE
end if;
>>
sequence_acn_child_decode(sChName, sChildContent, sErrCode, soSaveBitStrmPosStatement) ::= <<
--Decode <sChName>
<soSaveBitStrmPosStatement>
<sChildContent>
>>


sequence_mandatory_child_encode(sChName, sChildContent, soSaveBitStrmPosStatement) ::= <<
-- Encode <sChName>
<soSaveBitStrmPosStatement>
<sChildContent>
>>
sequence_mandatory_child_decode(sChName, sChildContent, soSaveBitStrmPosStatement) ::= <<
-- Decode <sChName>
<soSaveBitStrmPosStatement>
<sChildContent>
>>

sequence_always_present_child_encode(p, sAcc, sChName, soChildContent, soChildExpr, sChildTypedef, soSaveBitStrmPosStatement) ::= <<
-- Encode <sChName>
-- marked as ALWAYS PRESENT, so do not look in exist
<soSaveBitStrmPosStatement>
<if(soChildContent)><soChildContent><else>null;<endif>
>>

sequence_always_present_child_decode(p, sAcc, sChName, soChildContent, soChildExpr, sChildTypedef, soSaveBitStrmPosStatement) ::= <<
-- Decode <sChName>
-- marked as ALWAYS PRESENT, so do not look in exist
<soSaveBitStrmPosStatement>
<p>.Exist.<sChName> := 1;
<soChildContent>
>>

sequence_always_absent_child_encode(p, sAcc, sChName, sChildContent, sChildTypedef, soSaveBitStrmPosStatement) ::= <<
-- Encode <sChName>
-- marked as ALWAYS ABSENT, so do not encode anything
<soSaveBitStrmPosStatement>
null;

>>

sequence_always_absent_child_decode(p, sAcc, sChName, sChildContent, sChildTypedef, soSaveBitStrmPosStatement) ::= <<
-- Decode <sChName>
-- marked as ALWAYS ABSENT, so do not decode anything
<p>.Exist.<sChName> := 0;
result := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
<soSaveBitStrmPosStatement>
>>


sequence_optional_child_encode(p, sAcc, sChName, sChildContent, soExistVar, soChildExpr, sChildTypedef, soSaveBitStrmPosStatement) ::= <<
-- Encode <sChName>
<soSaveBitStrmPosStatement>
if <p>.Exist.<sChName> = 1 then
	<sChildContent>
end if;
>>

sequence_optional_child_decode(p, sAcc, sChName, sChildContent, soExistVar, soChildExpr, sChildTypedef, soSaveBitStrmPosStatement) ::= <<
-- Decode <sChName>
<soSaveBitStrmPosStatement>
if <p>.Exist.<sChName> = 1 then
	<sChildContent>
end if;
>>

sequence_default_child_encode(p, sAcc, sChName, sChildContent, sInitWithDefaultValue, soExistVar, soChildExpr, sChildTypedef, soSaveBitStrmPosStatement) ::= <<
<sequence_optional_child_encode(p=p, sAcc=sAcc, sChName=sChName, sChildContent=sChildContent, soExistVar=soExistVar, soChildExpr=soChildExpr, sChildTypedef=sChildTypedef, soSaveBitStrmPosStatement=soSaveBitStrmPosStatement)>
>>


sequence_default_child_decode(p, sAcc, sChName, sChildContent, sInitWithDefaultValue, soExistVar, soChildExpr, sChildTypedef, soSaveBitStrmPosStatement) ::= <<
-- Decode <sChName>
<soSaveBitStrmPosStatement>
if <p>.Exist.<sChName> = 1 then
	<sChildContent>
else
    <sInitWithDefaultValue>
end if;
>>







sequence_call_post_encoding_function(p, sFncName, sBitStreamStartPos, sBitStreamPositionsNullPos) ::= <<
<sFncName>(<p>, <sBitStreamStartPos>, <sBitStreamPositionsNullPos>, bs);
>>

sequence_call_post_decoding_validator(p, sFncName, sBitStreamStartPos, sBitStreamPositionsNullPos) ::= <<
result := <sFncName>(<p>, <sBitStreamStartPos>, <sBitStreamPositionsNullPos>, bs);
>>







/* Choice like uper*/

Choice_encode(p, sAcc, arrsChildren, nLastItemIndex, sChoiceIndexName, td/*:FE_ChoiceTypeDefinition*/, nIndexSizeInBits, sErrCode) ::= <<
case <p><sAcc>kind is
    <arrsChildren; separator="\n">
end case;
>>

Choice_decode(p, sAcc, arrsChildren, nLastItemIndex, sChoiceIndexName, td/*:FE_ChoiceTypeDefinition*/, nIndexSizeInBits, sErrCode) ::= <<
result.ErrorCode := <sErrCode>;
adaasn1rtl.encoding.Dec_ConstraintWholeNumber(bs, <sChoiceIndexName>, 0, <nLastItemIndex>, <nIndexSizeInBits>, result.Success);
if result.Success AND <sChoiceIndexName> \>= 0 AND  <sChoiceIndexName> \<= <nLastItemIndex> then
    case <td.index_range>(<sChoiceIndexName>) is
        <arrsChildren; separator="\n">
    end case;
end if;
>>

ChoiceChildAlwaysAbsent_encode(p, sAcc, sChildID, nChildIndex, sErrorCodeName) ::= <<
when <sChildID> =>
    result := <rtlModuleName()>.ASN1_RESULT'(Success => false, ErrorCode => <sErrorCodeName>);		-- COVERAGE_IGNORE
>>

ChoiceChildAlwaysAbsent_decode(p, sAcc, sChildID, nChildIndex, sErrorCodeName) ::= <<
when <nChildIndex> =>
    result := <rtlModuleName()>.ASN1_RESULT'(Success => false, ErrorCode => <sErrorCodeName>);		-- COVERAGE_IGNORE
>>


ChoiceChild_encode(p, sAcc, sChildID, nChildIndex, nIndexSizeInBits, nLastItemIndex, sChildContent, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr) ::= <<
when <sChildID> =>
    adaasn1rtl.encoding.Enc_ConstraintWholeNumber(bs, <nChildIndex>, 0, <nIndexSizeInBits>);
	<sChildContent>
>>

ChoiceChild_decode(p, sAcc, sChildID, nChildIndex, nIndexSizeInBits, nLastItemIndex, sChildContent, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr) ::= <<
when <nChildIndex> =>
  <p> := <sChoiceTypeName>'(kind => <sChildID>, <sChildName> => <sChildInitExpr>);
  <sChildContent>
>>

/* Choice with Enum determinant */

ChoiceChild_Enum_encode(p, sAcc, sEnmName, sChildID, sChildBody, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr) ::= <<
when <sChildID> =>
	<sChildBody>
>>

ChoiceChild_Enum_decode(p, sAcc, sEnmName, sChildID, sChildBody, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr) ::= <<
when <sEnmName> =>
  <p> := <sChoiceTypeName>'(kind => <sChildID>, <sChildName> => <sChildInitExpr>);
  <sChildBody>

>>

Choice_Enum_encode(p, sAcc, arrsChildren, sEnmExtFld, sErrCode) ::= <<
case <p><sAcc>kind is
    <arrsChildren; separator="\n">
end case;
>>

Choice_Enum_decode(p, sAcc, arrsChildren, sEnmExtFld, sErrCode) ::= <<
case <sEnmExtFld> is
    <arrsChildren; separator="\n">
end case;
>>




/* Choice with presence determinants */


ChoiceChild_preWhen_bool_condition(sExtFld) ::= "<sExtFld>"
ChoiceChild_preWhen_int_condition(sExtFld, sVal) ::= "(<sExtFld> = <sVal>)"
ChoiceChild_preWhen_str_condition(sExtFld, sVal, arrsNullChars, arruVal) ::= "(<sExtFld> = \"<sVal>\"<if(arrsNullChars)> & <arrsNullChars; wrap, anchor, separator=\" & \"><endif>)"

Choice_preWhen_encode(p, sAcc, arrsChildren, sErrCode) ::= <<
case <p><sAcc>kind is
    <arrsChildren; separator="\n">
end case;
>>

ChoiceChild_preWhen_encode(p, sAcc, sChildID, sChildBody, arrsConditions, bFirst, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr) ::= <<
when <sChildID> =>
	<sChildBody>
>>



Choice_preWhen_decode(p, sAcc, arrsChildren, sErrCode) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
<arrsChildren; separator="\n">
else
    result := <rtlModuleName()>.ASN1_RESULT'(Success => false, ErrorCode => <sErrCode>);		-- COVERAGE_IGNORE
end if;
>>

ChoiceChild_preWhen_decode(p, sAcc, sChildID, sChildBody, arrsConditions, bFirst, sChildName, sChildTypeDef, sChoiceTypeName, sChildInitExpr) ::= <<
<if(bFirst)>if<else>elsif<endif> (<arrsConditions; separator=" and ">) then
  <p> := <sChoiceTypeName>'(kind => <sChildID>, <sChildName> => <sChildInitExpr>);
  <sChildBody>
>>








/* Updates */


MultiAcnUpdate_checkEqual_pri0(p1,p2) ::= "(<p1> = <p2>)"
MultiAcnUpdate_checkEqual_str0(p1,p2) ::= "(<p1> = <p2>)"

MultiAcnUpdate_get_first_init_value_pri(sV0, sVi, sChPath, bIsFirst, bIsSingleElement) ::= <<
<if(bIsFirst)>if<else>elsif<endif> <sVi>_is_initialized then		--COVERAGE_IGNORE
    <sV0> := <sVi>;													--COVERAGE_IGNORE
>>

MultiAcnUpdate_get_first_init_value_str(sV0, sVi, sChPath, bIsFirst, bIsSingleElement) ::= <<
<MultiAcnUpdate_get_first_init_value_pri(sV0=sV0, sVi=sVi, sChPath=sChPath, bIsFirst=bIsFirst, bIsSingleElement=bIsSingleElement)>
>>

MultiAcnUpdate_checkEqual_pri(sV0, sVi, sChPath, bIsAlwaysInit) ::= "((<sVi>_is_initialized and <sV0> = <sVi>) or not <sVi>_is_initialized)"
MultiAcnUpdate_checkEqual_str(sV0, sVi, sChPath, bIsAlwaysInit) ::= "((<sVi>_is_initialized and <sV0> = <sVi>) or not <sVi>_is_initialized)"

MultiAcnUpdate(v, sV0, sErrCode, arrsLocalDeclarations, arrsLocalUpdateStatements, arrsGetFirstIntValue, bIsFirstIntValueSingle, arrsLocalCheckEquality, sDefaultExpr) ::= <<
declare
    <arrsLocalDeclarations; separator="\n">
begin

    <arrsLocalUpdateStatements; separator="\n">

    <arrsGetFirstIntValue; separator="\n">
    else
        result := <rtlModuleName()>.ASN1_RESULT'(Success => False, ErrorCode => <sErrCode>);		--COVERAGE_IGNORE
    end if;

    result := <rtlModuleName()>.ASN1_RESULT'(Success => result.Success and (<arrsLocalCheckEquality; separator=" and ">), ErrorCode => <sErrCode>);
    <v>_is_initialized := result.Success;
end;
>>




PresenceDependency(v, sSeqPath, sAcc, sChildName) ::= <<
<v>_is_initialized := True;
<v> := (<sSeqPath><sAcc>exist.<sChildName> = 1);
>>




SizeDependency(v, sCount, nMin, nMax, bCheckRange, sTypedefName) ::= <<
<v>_is_initialized := True;
<v> := <sTypedefName>(<sCount>);
<if(bCheckRange)>
result.success := <v> \>= <nMin> and <v> \<= <nMax>;

<endif>
>>

SizeDependencyFixedSize(v, nFixedSize) ::= <<
<v>_is_initialized := True;
<v> := <nFixedSize>;
>>


getStringSize(p) ::= "<rtlModuleName()>.getStringSize(<p>)"
getSizeableSize(p, sAcc, bIsUnsigned) ::= "<p>.Length"



ChoiceDependencyPres(v, sChPath, sAcc, arrsChoiceItems) ::= <<
case <sChPath><sAcc>kind is
    <arrsChoiceItems; separator="\n">
end case;
>>

ChoiceDependencyIntPres_child(v, sChildNamePresent, sChildRetVal) ::= <<
when <sChildNamePresent> =>
    <v>_is_initialized := True;
	<v> := <sChildRetVal>;
>>

ChoiceDependencyStrPres_child(v, sChildNamePresent, sChildRetVal, arruChildRetValBytes, arrsNullChars) ::= <<
when <sChildNamePresent> =>
    <v>_is_initialized := True;
	<v> := "<sChildRetVal>"<if(arrsNullChars)> & <arrsNullChars; wrap, anchor, separator=" & "><endif>;
>>



ChoiceDependencyEnum_Item(v, sChildCID, sChildCIDHolder, sEnumCName, bIsOptional) ::= <<
when <sChildCID> =>
    <v>_is_initialized := True;
	<v> := <sEnumCName>;
>>

ChoiceDependencyEnum(sV, sChPath, sAcc, arrsChoiceEnumItems, bIsOptional, sDefaultExpr) ::= <<
case <sChPath><sAcc>kind is
    <arrsChoiceEnumItems; separator="\n">
end case;
>>

checkAccessPath(arrsCheckPaths, sUpdateStatement, v, sInitExpr) ::= <<
if (<arrsCheckPaths; separator=" and then ">) then
    <sUpdateStatement>
end if;
>>



SizeDependency_oct_str_containing(p, sFuncName, sReqBytesForUperEncoding, v, bIsOctet, sComment) ::= <<
--first encode containing type to a temporary bitstream. That's the only way to learn in advance the size of the encoding octet string
<sFuncName>_aux(<p>, tmpBs, result);
if result.success then
	<v> := <rtlModuleName()>.Asn1UInt(<if(bIsOctet)>adaasn1rtl.encoding.BitStream_current_length_in_bytes(tmpBs)<else>tmpBs.Current_Bit_Pos<endif>);
	<v>_is_initialized := True;
end if;
>>


octet_string_containing_ext_field_func_encode(p, sFuncName, sReqBytesForUperEncoding, sExtField, sErrCode, soInner) ::= <<
adaasn1rtl.encoding.uper.BitStream_EncodeOctetString_no_length(bs, tmpBs.Buffer, Integer(<sExtField>));
>>

octet_string_containing_ext_field_func_decode(p, sFuncName, sReqBytesForUperEncoding, sExtField, sErrCode, soInner) ::= <<
--open new scope to declare some variables
declare
    tmpBs : adaasn1rtl.encoding.Bitstream := adaasn1rtl.encoding.BitStream_init(<sReqBytesForUperEncoding>);
begin
	--decode to a temporary bitstream
	result := <rtlModuleName()>.ASN1_RESULT'(Success => Integer(<sExtField>) \<= <sReqBytesForUperEncoding>, ErrorCode => <sErrCode>);
	if result.success then
		adaasn1rtl.encoding.uper.BitStream_DecodeOctetString_no_length(bs, tmpBs.Buffer, Integer(<sExtField>), result.success);
		if result.success then
			<sFuncName>_aux(<p>, tmpBs, result);
		end if;
	end if;

end;
>>

bit_string_containing_ext_field_func_encode(p, sFuncName, sReqBytesForUperEncoding, sReqBitsForUperEncoding, sExtField, sErrCode) ::= <<
adaasn1rtl.encoding.BitStream_AppendBits(bs, tmpBs.Buffer, Integer(<sExtField>));
>>

bit_string_containing_ext_field_func_decode(p, sFuncName, sReqBytesForUperEncoding, sReqBitsForUperEncoding, sExtField, sErrCode) ::= <<
--open new scope to declare some variables
declare
    tmpBs : adaasn1rtl.encoding.Bitstream := adaasn1rtl.encoding.BitStream_init(<sReqBytesForUperEncoding>);
begin
	--decode to a temporary bitstream
	result := <rtlModuleName()>.ASN1_RESULT'(Success => Integer(<sExtField>) \<= <sReqBitsForUperEncoding>, ErrorCode => <sErrCode>);
	if result.success then
		adaasn1rtl.encoding.BitStream_ReadBits(bs, tmpBs.Buffer, Integer(<sExtField>), result.success);
		if result.success then
			<sFuncName>_aux(<p>, tmpBs, result);
		end if;
	end if;

end;

>>


oct_external_field_encode(sTypedefName, p, sAcc, noSizeMin, nSizeMax, sExtFld, bIsUnsigned, nAlignSize, sErrCode) ::= <<
adaasn1rtl.encoding.uper.BitStream_EncodeOctetString_no_length(bs, <p><sAcc>Data, Integer(<p><sAcc>Length));
>>

oct_external_field_decode(sTypedefName, p, sAcc, noSizeMin, nSizeMax, sExtFld, bIsUnsigned, nAlignSize, sErrCode) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <if(noSizeMin)><noSizeMin>\<=<sExtFld> AND <endif><sExtFld>\<=<nSizeMax>, ErrorCode => <sErrCode>);
if result.Success then
    <p>.Length := Integer(<sExtFld>);
    adaasn1rtl.encoding.uper.BitStream_DecodeOctetString_no_length(bs, <p><sAcc>Data, Integer(<p><sAcc>Length), result.success);
end if;
>>

oct_external_field_fix_size_encode(sTypedefName, p, sAcc, noSizeMin, nSizeMax, sExtFld, bIsUnsigned, nAlignSize, sErrCode) ::= <<
adaasn1rtl.encoding.uper.BitStream_EncodeOctetString_no_length(bs, <p><sAcc>Data, Integer(<nSizeMax>));
>>


oct_external_field_fix_size_decode(sTypedefName, p, sAcc, noSizeMin, nSizeMax, sExtFld, bIsUnsigned, nAlignSize, sErrCode) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <if(noSizeMin)><noSizeMin>\<=<sExtFld> AND <endif><sExtFld>\<=<nSizeMax>, ErrorCode => <sErrCode>);
if result.Success then
    adaasn1rtl.encoding.uper.BitStream_DecodeOctetString_no_length(bs, <p><sAcc>Data, Integer(<nSizeMax>), result.success);
end if;
>>


bit_string_external_field_encode(sTypeDefName, p, sErrCode, sAcc, noSizeMin, nSizeMax, sExtFld) ::= <<
adaasn1rtl.encoding.BitStream_AppendBitArray(bs, <p><sAcc>Data, Integer(<sExtFld>));
>>

bit_string_external_field_decode(sTypeDefName, p, sErrCode, sAcc, noSizeMin, nSizeMax, sExtFld) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <if(noSizeMin)><noSizeMin>\<=<sExtFld> AND <endif><sExtFld>\<=<nSizeMax>, ErrorCode => <sErrCode>);
if result.Success then
   <p>.Length := Integer(<sExtFld>);
    adaasn1rtl.encoding.BitStream_ReadBitArray(bs, <p><sAcc>Data, Integer(<sExtFld>), result.success);
end if;
>>

bit_string_external_field_fixed_size_encode(sTypeDefName, p, sErrCode, sAcc, noSizeMin, nSizeMax, sExtFld) ::= <<
adaasn1rtl.encoding.BitStream_AppendBitArray(bs, <p><sAcc>Data, Integer(<nSizeMax>));
>>

bit_string_external_field_fixed_size_decode(sTypeDefName, p, sErrCode, sAcc, noSizeMin, nSizeMax, sExtFld) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <if(noSizeMin)><noSizeMin>\<=<sExtFld> AND <endif><sExtFld>\<=<nSizeMax>, ErrorCode => <sErrCode>);
if result.Success then
    adaasn1rtl.encoding.BitStream_ReadBitArray(bs, <p><sAcc>Data, Integer(<nSizeMax>), result.success);
end if;
>>

bit_string_null_terminated_encode(sTypeDefName, p, sErrCode, sAcc, i, noSizeMin, nSizeMax, arruNullBytes, nBitPatternLength) ::= <<
adaasn1rtl.encoding.BitStream_AppendBitArray(bs, <p><sAcc>Data, <p><sAcc>Length);
<rtlModuleName()>.encoding.BitStream_AppendBits(bs, <rtlModuleName()>.OctetBuffer'(<arruNullBytes:{b|<i>=>16#<b;format="X2">#}; wrap, anchor, separator=", ">), <nBitPatternLength>);
>>

bit_string_null_terminated_decode(sTypeDefName, p, sErrCode, sAcc, i, noSizeMin, nSizeMax, arruNullBytes, nBitPatternLength)  ::= <<
<rtlModuleName()>.encoding.BitStream_ReadBits_nullterminated(bs, <p><sAcc>Data, <p><sAcc>Length, <rtlModuleName()>.OctetBuffer'(<arruNullBytes:{b|<i>=>16#<b;format="X2">#}; wrap, anchor, separator=", ">), <nBitPatternLength>, result.Success);
if not result.Success then
    result.errorcode := <sErrCode>;		-- COVERAGE_IGNORE
end if;
>>

bit_string_null_terminated_decode0(p, sErrCode, sAcc, i, noSizeMin, nSizeMax, arruNullBytes, nBitPatternLength) /*nogen*/ ::= <<
<i> := 1;
result := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
while result.Success and then <i>\<= <nSizeMax> and then not <rtlModuleName()>.encoding.BitStream_bitPatternMatches(bs,<rtlModuleName()>.OctetBuffer'(<arruNullBytes:{b|<i>=>16#<b;format="X2">#}; wrap, anchor, separator=", ">), <nBitPatternLength>)  loop
    pragma Loop_Invariant (<i> >=1 and <i>\<=<nSizeMax>);
    pragma Loop_Invariant (bs.Current_Bit_Pos \>= bs.Current_Bit_Pos'Loop_Entry);
    pragma Loop_Invariant (bs.Current_Bit_Pos\<=bs.Current_Bit_Pos'Loop_Entry + (<i>-1));
    <rtlModuleName()>.encoding.BitStream_ReadBit(bs, <p>.Data(<i>), result.Success);
    if not result.Success then
        result.errorcode := <sErrCode>;		-- COVERAGE_IGNORE
    end if;
    <i> := <i> + 1;
end loop;

if result.Success and <i> = <nSizeMax>+1  then
	-- maximum number of elements was decoded. Make sure that the following bits is the termination pattern
	result.Success := <rtlModuleName()>.encoding.BitStream_bitPatternMatches(bs,<rtlModuleName()>.OctetBuffer'(<arruNullBytes:{b|<i>=>16#<b;format="X2">#}; wrap, anchor, separator=", ">), <nBitPatternLength>);
	if result.Success then
		<rtlModuleName()>.encoding.BitStream_SkipBits(bs, <nBitPatternLength>);
		<p>.Length := <i>-1;
	end if;
	result := <rtlModuleName()>.ASN1_RESULT'(Success => result.Success, ErrorCode => <sErrCode>);
elsif result.Success and <i> \< <nSizeMax>+1 then
	<p>.Length := <i>-1;
	<rtlModuleName()>.encoding.BitStream_SkipBits(bs, <nBitPatternLength>);
	result := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
else
	result := <rtlModuleName()>.ASN1_RESULT'(Success => false, ErrorCode => <sErrCode>); --COVERAGE_IGNORE
end if;
>>


octet_string_containing_func_encode(p, sFuncName, sReqBytesForAcnEncoding, nBits, nMinSize, nMaxSize, bFixedSize) ::= <<
--open new scope to declare some variables
declare
    tmpBs : adaasn1rtl.encoding.Bitstream := adaasn1rtl.encoding.BitStream_init(<sReqBytesForAcnEncoding>);
	data_length : Integer;
begin
	--encode value to a temporary bit stream
	<sFuncName>_aux(<p>, tmpBs, result);
	if result.success then
		data_length := adaasn1rtl.encoding.BitStream_current_length_in_bytes(tmpBs);
		<if(bFixedSize)>
        adaasn1rtl.encoding.uper.BitStream_EncodeOctetString_no_length (bs, tmpBs.Buffer, data_length);

		<else>
        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, Asn1Int (data_length), Asn1Int (<nMinSize>), <nBits>);
        adaasn1rtl.encoding.uper.BitStream_EncodeOctetString_no_length (bs, tmpBs.Buffer, data_length);

		<endif>
	end if;
end;
>>

octet_string_containing_func_decode(p, sFuncName, sReqBytesForAcnEncoding, nBits, nMinSize, nMaxSize, bFixedSize) ::= <<
--open new scope to declare some variables
declare
    tmpBs : adaasn1rtl.encoding.Bitstream := adaasn1rtl.encoding.BitStream_init(<sReqBytesForAcnEncoding>);
    <if(!bFixedSize)>
	data_length : Integer;

    <endif>
begin
	--decode to a temporary bitstream
	<if(bFixedSize)>
    adaasn1rtl.encoding.uper.BitStream_DecodeOctetString_no_length (bs, tmpBs.Buffer, <nMinSize>, result.success);
	if result.success then
		<sFuncName>_aux(<p>, tmpBs, result);
	end if;

	<else>
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumberInt(bs, data_length, <nMinSize>, <nMaxSize>, <nBits>, result.success);
    if result.success then
        adaasn1rtl.encoding.uper.BitStream_DecodeOctetString_no_length (bs, tmpBs.Buffer, data_length, result.success);
	    if result.success then
		    <sFuncName>_aux(<p>, tmpBs, result);
	    end if;
    end if;

	<endif>
end;
>>


bit_string_containing_func_encode(p, sFuncName, sReqBytesForAcnEncoding, sReqBitsForUperEncoding, nBits, nMinSize, nMaxSize, bFixedSize) ::= <<
--open new scope to declare some variables
declare
    tmpBs : adaasn1rtl.encoding.Bitstream := adaasn1rtl.encoding.BitStream_init(<sReqBytesForAcnEncoding>);
	data_length : Integer;
begin
	--encode value to a temporary bit stream
	<sFuncName>_aux(<p>, tmpBs, result);
	if result.success then
		data_length := tmpBs.Current_Bit_Pos;
		<if(bFixedSize)>
        adaasn1rtl.encoding.BitStream_AppendBits (bs, tmpBs.Buffer, data_length);

		<else>
        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, Asn1Int (data_length), Asn1Int (<nMinSize>), <nBits>);
        adaasn1rtl.encoding.BitStream_AppendBits (bs, tmpBs.Buffer, data_length);

		<endif>
	end if;
end;
>>

bit_string_containing_func_decode(p, sFuncName, sReqBytesForAcnEncoding, sReqBitsForUperEncoding, nBits, nMinSize, nMaxSize, bFixedSize) ::= <<
--open new scope to declare some variables
declare
    tmpBs : adaasn1rtl.encoding.Bitstream := adaasn1rtl.encoding.BitStream_init(<sReqBytesForAcnEncoding>);
    <if(!bFixedSize)>
	data_length : Integer;

    <endif>
begin
	--decode to a temporary bitstream
	<if(bFixedSize)>
    adaasn1rtl.encoding.BitStream_ReadBits (bs, tmpBs.Buffer, <nMinSize>, result.success);
	if result.success then
		<sFuncName>_aux(<p>, tmpBs, result);
	end if;

	<else>
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumberInt(bs, data_length, <nMinSize>, <nMaxSize>, <nBits>, result.success);
    if result.success then
        adaasn1rtl.encoding.BitStream_ReadBits (bs, tmpBs.Buffer, data_length, result.success);
	    if result.success then
		    <sFuncName>_aux(<p>, tmpBs, result);
	    end if;
    end if;

    <endif>
end;
>>
