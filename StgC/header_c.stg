group c_header;

rtlModuleName() ::= ""

indentation(sStatement) ::=<<
    <sStatement>
>>

PrintSpecificationFile(sFileNameWithNoExtUpperCase, sPackageName, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrototypes, arrsUtilityDefines, bHasEncodings, bXer) ::= <<
#ifndef GENERATED_ASN1SCC_<sFileNameWithNoExtUpperCase>_H
#define GENERATED_ASN1SCC_<sFileNameWithNoExtUpperCase>_H
/*
Code automatically generated by asn1scc tool
*/
#include "asn1crt.h"
<if(bHasEncodings)>
#include "asn1crt_encoding.h"

<endif>

<arrsIncludedModules:{inc| #include "<inc>.h"}; separator="\n">

#ifdef  __cplusplus
extern "C" {
#endif


<arrsTypeAssignments:{tas|<tas>}; separator="\n">

<arrsValueAssignments:{vas|<vas>}; separator="\n">

/* ================= Encoding/Decoding function prototypes =================
 * These functions are placed at the end of the file to make sure all types
 * have been declared first, in case of parameterized ACN encodings
 * ========================================================================= */

<arrsPrototypes:{proto|<proto>}; separator="\n">


#ifdef  __cplusplus
}
<arrsUtilityDefines; separator="\n">

#endif

#endif

>>

Define_TAS(sTypeDefinition, arrsProcs) ::= <<
<sTypeDefinition>

<arrsProcs; separator="\n\n">
>>

PrintValueAssignment(sName, sTypeDecl, sValue) ::= "extern const <sTypeDecl> <sName>;"


/*
C TYPES
*/

Declare_Integer() ::="asn1SccSint"
Declare_PosInteger() ::="asn1SccUint"
Declare_IntegerNoRTL() ::="asn1SccSint"
Declare_PosIntegerNoRTL() ::="asn1SccUint"

Declare_Boolean() ::= "flag"
Declare_Real() ::= "asn1Real"

Declare_Int8() ::="int8_t"
Declare_UInt8() ::="uint8_t"
Declare_Int16() ::="int16_t"
Declare_UInt16() ::="uint16_t"
Declare_Int32() ::="int32_t"
Declare_UInt32() ::="uint32_t"
Declare_Int64() ::="int64_t"
Declare_UInt64() ::="uint64_t"

Declare_Real32() ::= "float"
Declare_Real64() ::= "double"

Declare_BooleanNoRTL() ::= "flag"
Declare_RealNoRTL() ::= "asn1Real"


Declare_Null() ::= "NullType"
Declare_NullNoRTL() ::= "NullType"
Declare_ObjectIdentifier() ::= "Asn1ObjectIdentifier"
Declare_ObjectIdentifierNoRTL() ::= "Asn1ObjectIdentifier"

Declare_Asn1LocalTime                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTime                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZone     	()::= "Asn1TimeWithTimeZone"
Declare_Asn1Date                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTime            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTime              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZone	()::= "Asn1DateTimeWithTimeZone"

Declare_Asn1LocalTimeNoRTL                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTimeNoRTL                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZoneNoRTL     	()::= "Asn1TimeWithTimeZone"
Declare_Asn1DateNoRTL                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTimeNoRTL            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTimeNoRTL              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZoneNoRTL	()::= "Asn1DateTimeWithTimeZone"


Define_SubType(sTypeDefinitionName, soParentTypePackage, sParentType, soNewRange, soExtraDefs, arrsAnnots) ::= <<
typedef <sParentType> <sTypeDefinitionName>;
<soExtraDefs>
>>





/******************************************************************************************************************************/
/***********************************       NEW TYPE DEFINITIONS    ************************************************************/
/******************************************************************************************************************************/

/***********************************       ENUMERATED    ************************************************************/

Define_new_enumerated_item(td/*:FE_EnumeratedTypeDefinition*/, sName, nValue) ::= "<sName> = <nValue>"

Define_new_enumerated_item_macro(td/*:FE_EnumeratedTypeDefinition*/, sAsn1Name, sCName) ::= "#define <td.typeName>_<sAsn1Name> <sCName>"

Define_new_enumerated(td/*:FE_EnumeratedTypeDefinition*/, arrsEnumNames, arrsEnumNamesAndValues, nIndexMax, arrsResolvingMacros) ::= <<
typedef enum {
    <arrsEnumNamesAndValues:{it|<it>}; separator=",\n">
} <td.typeName>;

// please use the following macros to avoid breaking code.
<arrsResolvingMacros; separator="\n">
>>



Define_subType_enumerated(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

Define_new_enumerated_private(td/*:FE_EnumeratedTypeDefinition*/, arrsValidEnumNames, arrsEnumNames) ::= <<
static const asn1SccSint <td.values_array>[] = {
    <arrsValidEnumNames:{it|<it>}; wrap, anchor, separator=",">
};

#define <td.values_array_count> <arrsValidEnumNames.Length>

#define <td.encoded_values_array> <td.values_array>

#define <td.encoded_values_array_count> <arrsEnumNames.Length>
>>

Define_subType_enumerated_private(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, arrsValidEnumNames, arrsEnumNames) ::= <<
static const asn1SccSint <td.values_array>[] = {
    <arrsValidEnumNames:{it|<it>}; wrap, anchor, separator=",">
};

#define <td.values_array_count> <arrsValidEnumNames.Length>

#define <td.encoded_values_array> <prTd.encoded_values_array>

#define <td.encoded_values_array_count> <prTd.encoded_values_array_count>
>>

/***********************************       STRING    ************************************************************/

Define_new_ia5string(td/*:FE_StringTypeDefinition*/, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
typedef char <td.typeName>[<nCMax>];
>>

Define_subType_ia5string(td/*:FE_StringTypeDefinition*/, prTd/*:FE_StringTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       OCTET STRING    ************************************************************/

Define_new_octet_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, arrsInvariants) ::= <<
typedef struct {
<if(!bFixedSize)>
    int nCount;

<endif>
    byte arr[<nMax>];
} <td.typeName>;

>>

Define_subType_octet_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       BIT STRING    ************************************************************/

Define_new_bit_string_named_bit(td/*:FE_SizeableTypeDefinition*/, sTargetLangBitName, sHexValue, sComment) ::= <<
#define <td.typeName>_<sTargetLangBitName> 0x<sHexValue>  /*<sComment>*/
>>

Define_new_bit_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, nMaxOctets, arrsNamedBits, arrsInvariants) ::= <<
<arrsNamedBits:{it|<it>}; separator="\n">

typedef struct {
<if(!bFixedSize)>
    int nCount; /*Number of bits in the array. Max value is : <nMax> */

<endif>
    byte arr[<nMaxOctets>];
} <td.typeName>;
>>

Define_subType_bit_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       SEQUENCE OF    ************************************************************/


Define_new_sequence_of(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, sChildType, soChildDefinition, arrsSizeClassDefinition, arrsSizeObjDefinition, arrsInvariants) ::= <<

<soChildDefinition>

typedef struct {
<if(!bFixedSize)>
    int nCount;

<endif>
    <sChildType> arr[<nMax>];
} <td.typeName>;
>>



Define_subType_sequence_of(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize, soChildDefinition) ::= <<

<soChildDefinition>

typedef <prTd.typeName> <td.typeName>;
>>


/***********************************       SEQUENCE     ************************************************************/

Define_new_sequence_child_bit(sName) ::= "unsigned long <sName>:1;"
Define_new_sequence_child(sName, sType, bIsOptional) ::= "<sType> <sName>;"

Define_new_sequence_save_pos_child(td/*:FE_SequenceTypeDefinition*/, sName, nMaxBytesInACN) ::= "BitStream <sName>;"

Define_new_sequence(td/*:FE_SequenceTypeDefinition*/, arrsChildren, arrsOptionalChildren, arrsChildrenDefinitions, arrsNullFieldsSavePos, arrsSizeDefinition, arrsInvariants) ::= <<
/*-- <td.typeName> --------------------------------------------*/
<arrsChildrenDefinitions; separator= "\n">
<if (arrsNullFieldsSavePos)>
typedef struct {
    <arrsNullFieldsSavePos; separator="\n">
} <td.extension_function_positions>;

<endif>
<if (arrsOptionalChildren)>
typedef struct {
    <arrsOptionalChildren; separator="\n">
} <td.exist>;

<endif>
typedef struct {
    <arrsChildren; separator="\n">

    <if (arrsOptionalChildren)>
    <td.exist> exist;

    <endif>
} <td.typeName>;
>>

Define_subType_sequence(td/*:FE_SequenceTypeDefinition*/, prTd/*:FE_SequenceTypeDefinition*/, soParentTypePackage, arrsOptionalChildren, arrsExtraDefs) ::= <<
typedef <prTd.typeName> <td.typeName>;
<if (arrsNullFieldsSavePos)>
typedef <prTd.extension_function_positions> <td.extension_function_positions>;

<endif>
>>

/***********************************       CHOICE    ************************************************************/


Define_new_choice_child(sName, sType, sPresent) ::=<<
<sType> <sName>;
>>

Define_new_choice(td/*:FE_ChoiceTypeDefinition*/, sChoiceIDForNone, sFirstChildNamePresent, arrsChildren, arrsPresent, arrsCombined, nIndexMax, arrsChildrenDefinitions, arrsSizeDefinition) ::= <<
/*-- <td.typeName> --------------------------------------------*/
<arrsChildrenDefinitions; separator= "\n">

typedef enum {
    <sChoiceIDForNone>,
    <arrsPresent:{ch|<ch>}; separator=",\n">
} <td.selection>;

typedef union {
    <arrsChildren:{ch|<ch>}; separator="\n">
} <td.union_name>;

typedef struct {
    <td.selection> kind;

    <td.union_name> u;
} <td.typeName>;
>>

Define_subType_choice(td/*:FE_ChoiceTypeDefinition*/, prTd/*:FE_ChoiceTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

Define_SubType_int_range(soParentTypePackage, sParentType, noMin, noMax) ::= <<
>>
