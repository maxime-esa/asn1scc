group c_header;

PrintHeaderFile(sFileNameWithNoExtUpperCase, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrototypes, arrsUtilityDefines) ::= <<
#ifndef GENERATED_ASN1SCC_<sFileNameWithNoExtUpperCase>_H
#define GENERATED_ASN1SCC_<sFileNameWithNoExtUpperCase>_H
/*
Code automatically generated by asn1scc tool
*/
<arrsIncludedModules:{inc| #include "<inc>.h"}; separator="\n">
#include "asn1crt.h"

#ifdef  __cplusplus
extern "C" {
#endif


<arrsTypeAssignments:{tas|<tas>}; separator="\n">

<arrsValueAssignments:{vas|<vas>}; separator="\n"> 

/* ================= Encoding/Decoding function prototypes =================
 * These functions are placed at the end of the file to make sure all types
 * have been declared first, in case of parameterized ACN encodings
 * ========================================================================= */

<arrsPrototypes:{proto|<proto>}; separator="\n"> 


#ifdef  __cplusplus
}
<arrsUtilityDefines; separator="\n">

#endif

#endif

>>

Define_TAS(sTypeDefinition, arrsProcs) ::= <<
<sTypeDefinition>

<arrsProcs; separator="\n\n">
>>

PrintValueAssignment(sTypeDecl, sName) ::= "extern const <sTypeDecl> <sName>;"


/*
C TYPES 
*/

Declare_Integer() ::="asn1SccSint"
Declare_PosInteger() ::="asn1SccUint"

Declare_Boolean() ::= "flag"
Declare_Real() ::= "asn1Real"
Declare_IA5String() ::= "char"
Declare_NumericString() ::= "char"
Declare_NullType() ::= "NullType"


Define_SubType(sTypeDefinitionName, soParentTypePackage, sParentType, soNewRange, soExtraDefs) ::= <<
typedef <sParentType> <sTypeDefinitionName>;
<soExtraDefs>
>>





/******************************************************************************************************************************/
/***********************************       NEW TYPE DEFINITIONS    ************************************************************/
/******************************************************************************************************************************/

/***********************************       ENUMERATED    ************************************************************/

Define_new_enumerated_item(sName, nValue) ::= "<sName> = <nValue>"

Define_new_enumerated(td/*:FE_EnumeratedTypeDefinition*/, arrsEnumNames, arrsEnumNamesAndValues, nIndexMax) ::= <<
typedef enum {
    <arrsEnumNamesAndValues:{it|<it>}; separator=",\n">
} <td.typeName>;
>>

Define_subType_enumerated(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       STRING    ************************************************************/

Define_new_ia5string(td/*:FE_StringTypeDefinition*/, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
typedef char <td.typeName>[<nCMax>];
>>

Define_subType_ia5string(td/*:FE_StringTypeDefinition*/, prTd/*:FE_StringTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       OCTET STRING    ************************************************************/

Define_new_octet_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize) ::= <<
typedef struct {
<if(!bFixedSize)>
    int nCount; 

<endif>    
    byte arr[<nMax>];
} <td.typeName>;

>>

Define_subType_octet_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       BIT STRING    ************************************************************/
Define_new_bit_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, nMaxOctets) ::= <<
typedef struct {
<if(!bFixedSize)>
    int nCount; /*Number of bits in the array. Max value is : <nMax> */

<endif>    
    byte arr[<nMaxOctets>];
} <td.typeName>;
>>

Define_subType_bit_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       SEQUENCE OF    ************************************************************/


Define_new_sequence_of(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, sChildType, soChildDefintion) ::= <<

<soChildDefintion>

typedef struct {
<if(!bFixedSize)>
    int nCount; 

<endif>    
    <sChildType> arr[<nMax>];
} <td.typeName>;
>>



Define_subType_sequence_of(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>


/***********************************       SEQUENCE OF    ************************************************************/

Define_new_sequence_child_bit(sName) ::= "unsigned int <sName>:1;"
Define_new_sequence_child(sName, sType) ::= "<sType> <sName>;"

Define_new_sequence(td/*:FE_SequenceTypeDefinition*/, arrsChildren, arrsOptionalChildren, arrsChildldrenDefintions) ::= <<
/*-- <td.typeName> --------------------------------------------*/
<arrsChildldrenDefintions; separator= "\n">

typedef struct {
    <arrsChildren; separator="\n">

    <if (arrsOptionalChildren)>
    struct {
        <arrsOptionalChildren; separator="\n">
    } exist;

    <endif>
} <td.typeName>;
>>

Define_subType_sequence(td/*:FE_SequenceTypeDefinition*/, prTd/*:FE_SequenceTypeDefinition*/, soParentTypePackage, arrsOptionalChildren) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       CHOICE    ************************************************************/


Define_new_choice_child(sName, sType, sPresent) ::=<<
<sType> <sName>;
>>

Define_new_choice(td/*:FE_ChoiceTypeDefinition*/, sChoiceIDForNone, sFirstChildNamePresent, arrsChildren, arrsPresent, nIndexMax, arrsChildldrenDefintions) ::= <<
/*-- <td.typeName> --------------------------------------------*/
<arrsChildldrenDefintions; separator= "\n">

typedef struct {
    enum {
        <sChoiceIDForNone>,
        <arrsPresent:{ch|<ch>}; separator=",\n"> 
    } kind;
    
    union {
        <arrsChildren:{ch|<ch>}; separator="\n">
    } u; 
} <td.typeName>;
>>

Define_subType_choice(td/*:FE_ChoiceTypeDefinition*/, prTd/*:FE_ChoiceTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

