group c_init;


initTypeAssignment_def(sVarName, sStar, sFuncName, sTypeDefName) ::= <<
void <sFuncName>(<sTypeDefName><sStar> <sVarName>);
>>

initTypeAssignment(sVarName, sStar, sFuncName, sTypeDefName, sContent, arrsLocalVariables) ::= <<
void <sFuncName>(<sTypeDefName><sStar> <sVarName>)
{
    <arrsLocalVariables; separator="\n">

	<sContent>
}
>>



initInteger(sVal, nValue) ::= "<sVal> = <nValue>;"
initReal(sVal, dValue) ::= "<sVal> = <dValue>;"
initBoolean(sVal, bValue) ::= "<sVal> = <if(bValue)>TRUE<else>FALSE<endif>;"
initIA5String(sPtr, sValue, arrsNullChars) ::= "strcpy(<sPtr>,\"<sValue>\");"
initEnumerated(sVal, sValue) ::= "<sVal> = <sValue>;"
initNull(sVal)    ::= "<sVal> = 0;"

initTestCaseIA5String(p, sAcc, nSize, nMaxSizePlusOne, i, sTasName, bAlpha, arrnAlphabetAsciiCodes, nAlphabetLength, bZero) ::= <<
<if(bZero)>
memset(<p>, 0x0, <nMaxSizePlusOne>);

<else>
<i> = 0;
memset(<p>, 0x0, <nMaxSizePlusOne>);
while (<i>\< <nSize>) {
    <if(bAlpha)>
    static byte allowedCharSet[] = {<arrnAlphabetAsciiCodes:{ch|0x<ch;format="X2">}; wrap, anchor, separator=",">}; 

    <p>[<i>] = allowedCharSet[<i> % <nAlphabetLength>];

    <else>
    <p>[<i>] = (char)(<i> % 128 == 0 ? 'A' : <i> % 128);

    <endif>
    <i> = <i> + 1;
}

<endif>
>>

/* BIT AND OCTET STRINGS */
initFixSizeBitOrOctString_bytei(p, sAcc, sI, sByteHexVal) ::= "<p><sAcc>arr[<sI>] = 0x<sByteHexVal>;"
initFixSizeBitOrOctString(p, sAcc,arrsBytes) ::= <<
<arrsBytes; separator="\n">
>>

initFixVarSizeBitOrOctString(p, sAcc, nSize, arrsBytes) ::= <<
<p><sAcc>nCount = <nSize>;
<arrsBytes; separator="\n">
>>

initTestCaseOctetString(p, sAcc, nSize, i, bIsFixedSize, bZero) ::= <<
<if(bZero)>
memset(<p><sAcc>arr, 0x0, <nSize>);

<else>
<i> = 0;
while (<i>\< <nSize>) {
    <p><sAcc>arr[<i>] = (byte)(<i>%256);
    <i> = <i> + 1;
}
<if(!bIsFixedSize)><p><sAcc>nCount = <if(bZero)>0<else><nSize><endif>;<endif>

<endif>
>>

initTestCaseBitString(p, sAcc, nSize, nSizeCeiled,  i, bIsFixedSize, bZero) ::= <<
<if(bZero)>
memset(<p><sAcc>arr, 0x0, <nSizeCeiled>/8);

<else>
<i> = 0;
while (<i>\< <nSizeCeiled>/8) {
    <p><sAcc>arr[<i>] = 0x55; /* --> 0101 0101 as in Ada*/
    <i> = <i> + 1;
}
<if(!bIsFixedSize)><p><sAcc>nCount = <if(bZero)>0<else><nSize><endif>;<endif>

<endif>
>>



/*SEQUENCE OF */

/*dummy in C*/
initSequence_pragma(p) ::= ""


initFixedSequenceOf(arrsInnerValues) ::= <<
<arrsInnerValues; separator="\n">        
>>


initVarSizeSequenceOf(p, sAcc, nSize, arrsInnerValues) ::= <<
<p><sAcc>nCount = <nSize>;
<arrsInnerValues; separator="\n">        
>>


initTestCaseSizeSequenceOf_innerItem(bFirst, bLastItem, nCaseIdx, sChildCaseInit, i, nCaseLen) ::= <<
<if(!bLastItem)><if(bFirst)>if<else>else if<endif> (<i> % <nCaseLen> == <nCaseIdx>)  {<else>else {<endif>
    <sChildCaseInit>
}>>

initTestCaseSizeSequenceOf(p, sAcc, nSize, bIsFixedSize, arrsInnerItems, bMultiCases, i) ::= <<
<i> = 0;
while (<i>\< <nSize>) {
    <arrsInnerItems; separator="\n">
    <i> = <i> + 1;
}
<if(!bIsFixedSize)><p><sAcc>nCount = <nSize>;<endif>
>>


/*SEQUENCE*/

initSequence_optionalChild(p, sAcc, sChName, sPresentFlag, sChildContent) ::=<<
<p><sAcc>exist.<sChName> = <sPresentFlag>;
<sChildContent>
>>

initSequence(arrsInnerValues) ::= <<
<arrsInnerValues; separator="\n">        
>>

initTestCase_sequence_child(p, sAcc, sChName, sChildContent, bOptional) ::= <<
/*set <sChName> */
<if(bOptional)><p><sAcc>exist.<sChName> = 1;<endif>
<sChildContent>
>>
initTestCase_sequence_child_opt(p, sAcc, sChName) ::= <<
<p><sAcc>exist.<sChName> = 0;
>>



initChoice(p1, sAccess, sChildContent, sChildKind) ::= <<
<p1><sAccess>kind = <sChildKind>;
<sChildContent>        
>>


initTestCase_choice_child(p, sAcc, sChildID, sChildContent, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
/*set <sChildName>*/
<p><sAcc>kind = <sChildID>;
<sChildContent>
>>
