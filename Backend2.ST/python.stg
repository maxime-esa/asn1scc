/*
* Copyright (c) 2008-2012 Semantix and (c) 2012-2015 Neuropublic
*
* This file is part of the ASN1SCC tool.
*
* Licensed under the terms of GNU General Public Licence as published by
* the Free Software Foundation.
*
*  For more informations see License.txt file
*/

group python;

//delimiters "$", "$"

/* Header of the file */
RootXml(arrsFiles) ::= <<
#!/usr/bin/env python
# ASN.1 Data model
asn1Files = []
asn1Modules = []
exportedTypes = {}
exportedVariables = {}
importedModules = {}
types = {}
variables = {}
$arrsFiles;separator="\n"$
>>


/* sFileName is a string with the current file name */
FileXml(sFileName, arrsModules) ::= <<
asn1Files.append("$sFileName$")
$arrsModules;separator="\n"$
>>


/* Per ASN.1 module. you can use:
  - the module name ($sName$)
  - the list of types that are exported by this module.
    Example of use:
    $arrsExpTypes:{x|"$x$"};separator=", "$
  - the list of variables that are exported by this module (arrsExpVars)
  - the list of imported modules (generated by template ImportedMod)
 Then you can use the list of types and variables defined in this module
 arrsTases is an array of strings generated by template TasXml
 arrsVases is an array of strings generated by template VasXml
*/
ModuleXml(sName, sCName, arrsImportedModules, arrsExpTypes, arrsExpVars, arrsTases, arrsVases) ::=<<
asn1Modules.append("$sName$")
exportedTypes["$sName$"] = [$arrsExpTypes:{x|"$x$"};separator=", "$]
exportedVariables["$sName$"] = [$arrsExpVars:{x|"$x$"};separator=", "$]
importedModules["$sName$"] = [$arrsImportedModules:{x|$x$};separator=", "$]

$arrsTases;separator="\n"$

$arrsVases;separator="\n"$
>>


/* An imported module with a list of imported types and variables */
ImportedMod(sName, sCName, arrsTypes, arrsVars) ::= <<
{"$sName$":{"ImportedTypes": [$arrsTypes:{t|"$t$"};separator=","$], "ImportedVariables": [$arrsVars:{t|"$t$"};separator=","$]}}
>>


/* A single Type Assignment, this is filled for all types of all modules */
TasXml(sName, nLine, nPos, sType, sCName, sAssigOp, sContract) ::= <<
types["$sName$"] = type("$sName$", (object,), {
    "Line": $nLine$, "CharPositionInLine": $nPos$, "type": type("$sName$_type", (object,), {
        $sType$
    })
})

>>


/* A single Variable Assignment (actual value not handled in python yet) */
VasXml(sName, nLine, nPos, sType, sValue, sCName) ::= <<
variables["$sName$"] = type("$sName$", (object,), {
    "Line": $nLine$,
    "CharPositionInLine": $nPos$,
    "varName": "$sCName$",
    "type": type("$sName$_type", (object,), {
        $sType$
    }),
    "value": $sValue$
})

>>

TypeGeneric(nLine, nPos, sSubType) ::= <<
"Line": $nLine$, "CharPositionInLine": $nPos$, $sSubType$
>>


/* Type with Min and Max constraint. sName is the type kind
   This template is used for Integer and Real types; for others,
   see MinMaxType2 */
MinMaxType(sName, sMin, sMax, bFixedSize) ::= <<
"kind": "$sName$", "Min": "$sMin$", "Max": "$sMax$"
>>


/* String types with size constraint: Bitstring, Octetstring, Ia5String,
   NumericString */
MinMaxType2(sName, sMin, sMax, bFixedSize) ::= <<
"kind": "$sName$", "Min": "$sMin$", "Max": "$sMax$"
>>

BooleanType () ::= <<"kind": "BooleanType">>

NullType () ::= <<"kind": "NullType">>

/* Integer and RealType full spec in MinMaxType */
IntegerType () ::= "IntegerType"

RealType () ::= "RealType"

/* String type full spec in MixMaxType2 */
BitStringType () ::= "BitStringType"

OctetStringType () ::= "OctetStringType"

IA5StringType () ::= "IA5StringType"

NumericStringType () ::= "NumericStringType"


AssigOpNormalType () ::= "="
AssigOpSpecialType () ::= "::"

/* Enumerated item, note the difference between sName, which is the enumerated
   name given in the input type, for example if you have
   MyType ::= ENUMERATED { a, b, c } then sName can be a, b or c
   and sCID which is a name built by the parser for removing ambiguities in
   some languages, e.g. if you have two types with the same enumerated name:
   MyOtherType ::= ENUMERATED { b, x, y }
   When this case happens, sCID will be either "MyType_b" or "MyOtherType_b"
   Check if your language needs this or not (C does, Ada does not)
   note: the renaming policy can be controlled with the command line of asn1scc
   for VDM: assuming sCID, to be checked
   nVal is the integer value of the enumerated, use it if needed
*/
EnumItem (sName, sCName, nVal, nLine, nPos, sCID) ::= <<
"$sName$": type("$sCID$", (object,), {
    "IntValue": $nVal$, "Line": $nLine$, "CharPositionInLine": $nPos$, "EnumID": "$sCID$"
})
>>


/* Enumerated type: arrsItems is an array of EnumItem */
EnumType(arrsItems) ::= <<
"kind": "EnumeratedType", "Extensible": "False", "ValuesAutoCalculated": "False", "EnumValues": {
    $arrsItems;separator=",\n"$
}
>>


/* Choice field
   Choice are discriminated unions, they have a name per field and a type :
   MyCHOICE ::= CHOICE {
       choice-a   Type-of-A,   -- choice-a is sName
       choice-b   Type-of-B,
       ...
  }
  sNamePresent is an unambiguous name to access the field
*/
ChoiceChild(sName, sCName, nLine, nPos, sChildContent, sNamePresent ) ::= <<
"$sName$": type("$sNamePresent$", (object,), {
    "Line": $nLine$, "CharPositionInLine": $nPos$, "EnumID": "$sNamePresent$", "type": type("$sNamePresent$_type", (object,), {
        $sChildContent$
    })
})
>>

ChoiceType(arrsChildren) ::= <<
"kind": "ChoiceType", "Children": {
    $arrsChildren;separator=",\n"$
}
>>


/* Sequence (record) field. May be optional and may have a default value */
SequenceChild(sName, sCName, bOptional, sDefVal, nLine, nPos, sChildContent ) ::= <<
"$sName$": type("$sName$", (object,), {
    "Optional": "$bOptional$"$if(sDefVal)$, "DefaultValue": "$sDefVal$"$endif$, "Line": $nLine$, "CharPositionInLine": $nPos$, "type": type("$sName$_type", (object,), {
        $sChildContent$
    })
})
>>


/* Full sequence (record) type */
SequenceType(arrsChildren) ::= <<
"kind": "SequenceType", "Children": {
    $arrsChildren;separator=",\n"$
}
>>


/* Sequence of (array) */
SequenceOfType(sMin, sMax, sChild) ::= <<
"kind": "SequenceOfType", "Min": "$sMin$", "Max": "$sMax$", "type": type("SeqOf_type", (object,), {
    $sChild$
})
>>


RefTypeMinMax(sMin, sMax, sName, sModName, sCName, sCModName) ::= <<
"kind": "ReferenceType", "ReferencedTypeName": "$sName$", "Min": "$sMin$", "Max": "$sMax$"$if(sModName)$, "ReferencedModName": "$sModName$"$endif$
>>


RefType(sName, sModName, sCName, sCModName) ::= <<
"kind": "ReferenceType", "ReferencedTypeName": "$sName$"$if(sModName)$, "ReferencedModName": "$sModName$"$endif$
>>

/* Possible additional information generated after the type itself */
Contract(sTypePattern, sExpr) ::= ""
TypePatternCommonTypes() ::= ""
TypePatternSequence(sName, sCName, arrsChildren) ::= ""
SequencePatternChild(sName, sCName) ::= ""
ContractExprMinMax(sPattern, sMin, sMax, bFixedSize) ::= ""
ContractExprSize(sPattern, sMin, sMax, bFixedSize) ::= ""
ContractExprSequence(arrsChildren) ::= ""

/* Print Values */
Print_IntegerValue(nVal) ::= "$nVal$"
Print_RealValue(dVal) ::= "$dVal$"
Print_StringValue(v) ::= <<"$v$">>
Print_TrueValue() ::= "True"
Print_FalseValue() ::= "False"
Print_BitStringValue(v) ::= <<"$v$">>
Print_OctetStringValue(arruOctets) ::= <<'$arruOctets; format="X2"$'>>
Print_RefValue(sName) ::= <<"$sName$">>
Print_SeqOfValue(arrsValues) ::= <<{$arrsValues; separator=", "$}>>
Print_SeqValue_Child(sName, sChildValue) ::= <<"$sName$": $sChildValue$>>
Print_SeqValue(arrsValues) ::= <<{$arrsValues; separator=", "$}>>
Print_ChValue(sAltName, sAltValue) ::= <<
{"choice": "$sAltName$", "$sAltName$": $sAltValue$}
>>
Print_NullValue() ::= "None"

