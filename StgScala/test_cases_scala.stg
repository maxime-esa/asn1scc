/*
* Copyright (c) 2008-2012 Semantix and (c) 2012-2015 Neuropublic
*
* This file is part of the ASN1SCC tool.
*
* Licensed under the terms of GNU General Public Licence as published by
* the Free Software Foundation.
*
*  For more informations see License.txt file
*/

group ch ;

rtlModuleName() ::= ""


PrintAutomaticTestCasesSpecFile(sModNameUpperCase, sModName, arrsIncludedModules, arrsTestFunctions) ::= <<
// test_cases_scala.stg:18
/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang._
import stainless.collection._
>>


PrintAutomaticTestCasesBodyFile(sModName, sTetscaseSpecFileName, arrsIncludedModules, arrsTasNames, arrsTypeAssignments, bXer) ::= <<
// test_cases_scala.stg:29
/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang._
import stainless.collection._
import java.io._

// test_cases_scala.stg:38
<arrsTypeAssignments:{tas|<tas>}; separator="\n">

>>





/* Encode Decode start*/





Codec_Encode(sModName, sFuncName, sVal) ::= <<
// test_cases_scala.stg:54
// Encode value
<sFuncName>(<sVal>, codec, true) match
    case Left(_) => return Left(1)
    case Right(_) => ()
>>

Codec_Decode(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
// test_cases_scala.stg:62
codec.base.bitStream.resetBitIndex()
// Decode value
<sFuncName>(codec) match
    case LeftMut(_) => return Left(2)
    case RightMut(pVal) => decodedPDU = pVal
>>

Codec_Decode_XER(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
// test_cases_scala.stg:71
bitStrm.attachBuffer(encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING)
// Decode value
bitStrm.<sFuncName>() match
    case Left(_) => return Left(2)
    case Right(pVal) => decodedPDU = pVal
>>

Codec_validate_output(sModName, sFuncName, sAmber) ::= <<
// test_cases_scala.stg:80
// validate decoded data
<sFuncName>(decodedPDU) match
    case Left(_) => return Left(3)
    case Right(_) => ()
>>

Codec_compare_input_with_output(sModName, sFuncName, sVal, sAmber) ::= <<
// test_cases_scala.stg:88
if !<sFuncName>(<sVal>, decodedPDU) then
    return Left(4)
>>

Codec_write_CharstreamToFile() ::= <<
// test_cases_scala.stg:94
<Codec_write_bitstreamToFile()>
>>

Codec_write_bitstreamToFile() ::= <<
// test_cases_scala.stg:99
val file = new File(filename+".dat")
val bw = new FileOutputStream(file)
val l = codec.base.bitStream.getLength
codec.base.bitStream.resetBitIndex()
bw.write(codec.base.bitStream.buf.toArrayRaws, 0, l)
bw.close()
>>

JoinItems(sPart, soNestedPart) ::= <<
// test_cases_scala.stg:107
<sPart>
<if(soNestedPart)>
<soNestedPart>
<endif>
>>


Codec_declare_EncInDecOut_variable(sPrmName, sType, sPrmValue) ::= <<
// test_cases_scala.stg:116
<sType> enc_<sPrmName> = <sPrmValue>;
<sType> dec_<sPrmName>;
>>

Codec_declare_DecIn_variable(sPrmName, sType) ::= "<sType> dec_<sPrmName>; /* test_cases_scala.stg:122 */"


PrintCodec_spec(sFuncName, sModName, sTasName, sStar, sVal) ::= <<
// test_cases_scala.stg:125
>>

PrintCodec_body(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements, sCodecClass) ::= <<
// test_cases_scala.stg:129
def <sFuncName>(<sVal>: <sTasName>, filename: String): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    var decodedPDU: <sTasName> = <sTasName>_Initialize() // TODO: does this always work?

    val codec = init<sCodecClass>Codec(<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING.toInt) // TODO: what to do with too large Longs?
    <sNestedStatements>
    ret
}
>>

PrintCodec_body_XER(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
// test_cases_scala.stg:142
flag <sFuncName>(const <sTasName><sStar> <sVal>, int* pErrCode, const char* filename)
{
    static <sTasName> decodedPDU;
    static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; /* +1 for zerosized types */
    ByteStream bitStrm;
    flag ret = TRUE;

    ByteStream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
    <sNestedStatements>
    return ret;
}
>>






/* Encode Decode End*/

PrintMain(sTestSuiteFilename) ::= <<
// test_cases_scala.stg:164
package asn1src

def printf_tests_failed(testCount: Int, failedCount: Int): Unit =
{
    println(s"[test failed] $failedCount out of $testCount failed.")
}

def printf_tests_passed(testCount: Int): Unit =
{
    println(s"[test success] All test cases ($testCount) run successfully.")
}

def printf_null(): Unit =
{
}

def printf_null_char(s: String): Unit =
{

}

def printf_message(message: String): Unit =
{
    println(s"$message")
}

def print_test_case_success(message: String, duration: Long): Unit =
{
    println(s"test case '$message' succeeded, duration was \t\t\t\t$duration ms")
}

@main def main(): Unit =
{
    val output = TestOutput(
        report_tests_failed = printf_tests_failed,
        report_all_tests_passed = printf_tests_passed,
        report_suite_begin = printf_null,
        report_suite_end = printf_null,
        report_case_begin = printf_null_char,
        report_case_end = printf_null,
        report_failure_begin = printf_null,
        report_failure_end = printf_null,
        report_failure_message = printf_message,
        report_test_case_success = print_test_case_success
    )

    val res = asn1scc_run_generated_testsuite(output)
    System.exit(res)
}

>>





PrintSuite_call_codec_generate_dat_file(sModName, sTasName, sAmber, sEnc, sStreamName) ::= <<
// test_cases_scala.stg:221
	if (result) {
		static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; /* +1 for zerosized types */
		<sStreamName>Stream bitStrm;
		FILE* fp;

  		<sStreamName>Stream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);

		result = <sTasName>_<sEnc>Encode(<sAmber>tmp, &bitStrm, &errCode, TRUE);
		fp = fopen("asn1scc_<sEnc>.dat","wb");

		if (fp==NULL)
		{
			printf("fopen failed !!!\n");
			return 2;
		}


		fwrite(encBuff,1,(size_t)<sStreamName>Stream_GetLength(&bitStrm),fp);
		fclose(fp);
	};
>>


PrintATCRunnerDefinition() ::= <<
// test_cases_scala.stg:246
package asn1src

case class TestOutput (
    report_tests_failed: (Int, Int) => Unit,
    report_all_tests_passed: Int => Unit,

    report_suite_begin: () => Unit,
    report_suite_end: () => Unit,

    report_case_begin: String => Unit,
    report_case_end: () => Unit,

    report_failure_begin: () => Unit,
    report_failure_end: () => Unit,
    report_failure_message: String => Unit,
    report_test_case_success: (String, Long) => Unit,
)

>>

PrintATCRunner(sTestSuiteFilename, arrsIncludedModules, arrsVars, arrsTestFunctions, arrsUsedPackages, arrsInitCalls, bGenerateDatFile) ::= <<
// test_cases_scala.stg:268
/*  Code automatically generated by asn1scc tool (stg macro : PrintATCRunner) */
package asn1src

import asn1scala._
import stainless.lang._
import stainless.collection._

def asn1scc_run_generated_testsuite(output: TestOutput): Int =
{
    var totalErrors: Int = 0
    <arrsVars; separator="\n">


    output.report_suite_begin()

    // test_cases_scala.stg:282
    <arrsTestFunctions;separator="\n\n">

    output.report_suite_end()

    if totalErrors > 0 then
        output.report_tests_failed(<arrsTestFunctions.Length>, totalErrors)
        return 1
    else
        output.report_all_tests_passed(<arrsTestFunctions.Length>)
        return 0

}

>>



invokeTestCaseAsFunc(sFuncName) ::= <<
// test_cases_scala.stg:301
totalErrors += <sFuncName>(output)
>>


emitTestCaseAsFunc_h(sFuncName) ::= <<
>>

emitTestCaseAsFunc_dummy_init(sTypeName, sFuncName, sDummyVarname) ::= <<
// test_cases_scala.stg:310
var <sDummyVarname>: <sTypeName> = <sFuncName>()
>>

emitTestCaseAsFunc_dummy_init_function(sTypeName, sFuncName, sDummyVarname) ::= <<
// test_cases_scala.stg:315
var <sDummyVarname>: <sTypeName> = <sFuncName>()
>>

emitTestCaseAsFunc(sFuncName, arrsVars, sModName, sTasName, sAmber, sEnc, bValueAssignment, sInitializeTcData, bStatic, sGenerateDatFile, arrsDummyInitStatementsNeededForStatementCoverage, sInitAmber) ::= <<
// test_cases_scala.stg:320
def <sFuncName>(output: TestOutput): Int =
{
    var totalErrors: Int = 0
    var result: Either[ErrorCode, Int] = Left(NOT_INITIALIZED_ERR_CODE)
    <arrsVars; separator="\n">

    output.report_case_begin("<sFuncName>")

    <sInitializeTcData>

    val start = System.currentTimeMillis()
    result = <sTasName>_<sEnc>enc_dec(tc_data, "<sFuncName>")
    val stop = System.currentTimeMillis()
    result match
        case Right(_) =>
            output.report_test_case_success("<sTasName>/<sFuncName>", stop - start)
        case Left(errorCode) =>
            output.report_failure_begin()
            errorCode match
                case 1 =>
                    // TODO: ATC may generate invalid messages that get rejected when encoding.
                    // This typically happens for determinants shared across multiple choices within a sequence.
                    // As such, we do not count it as an error.
                    // Note that the Ada and C backend do not always propagate errors when encoding fail,
                    // therefore they are "unaffected" by this bug.
                    output.report_failure_message("!!!!! Test case '<sTasName>/<sFuncName>' failed in encoding.")
                case 2 =>
                    output.report_failure_message("Test case '<sTasName>/<sFuncName>' failed in decoding.")
                    totalErrors = totalErrors + 1
                case 3 =>
                    output.report_failure_message("Test case '<sTasName>/<sFuncName>' failed in the validation of the decoded message.")
                    totalErrors = totalErrors + 1
                case 4 =>
                    output.report_failure_message("Test case '<sTasName>/<sFuncName>' failed. Encoded and decoded messages are different.")
                    totalErrors = totalErrors + 1
                case _ =>
                    output.report_failure_message("Unexpected error code in test case '<sFuncName>'.")
                    totalErrors = totalErrors + 1
            output.report_failure_message("========================================")
            output.report_failure_end()

    <sGenerateDatFile>

    output.report_case_end()
    totalErrors
}
>>


printTestCaseFileDef(sThisFile, arrsIncludedModules, arrsTestFunctionDefs) ::= <<
// test_cases_scala.stg:370
/*
Code automatically generated by asn1scc tool
*/
package asn1src

import stainless.lang._
import stainless.collection._

>>


printTestCaseFileBody(sThisFile, arrsIncludedModules, arrsTestFunctionBodies) ::= <<
// test_cases_scala.stg:380
/*  Code automatically generated by asn1scc tool (stg macro : printTestCaseFileBody) */
package asn1src

import asn1scala._
import stainless.lang._
import stainless.collection._

// test_cases_scala.stg:386
<arrsTestFunctionBodies;separator="\n\n">

>>
