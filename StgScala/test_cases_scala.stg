/*
* Copyright (c) 2008-2012 Semantix and (c) 2012-2015 Neuropublic
*
* This file is part of the ASN1SCC tool.
*
* Licensed under the terms of GNU General Public Licence as published by
* the Free Software Foundation.
*
*  For more informations see License.txt file
*/

group ch ;

rtlModuleName() ::= ""


PrintAutomaticTestCasesSpecFile(sModNameUpperCase, sModName, arrsIncludedModules, arrsTestFunctions) ::= <<
// test_cases_scala.stg:18
/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
>>


PrintAutomaticTestCasesBodyFile(sModName, sTetscaseSpecFileName, arrsIncludedModules, arrsTasNames, arrsTypeAssignments, bXer) ::= <<
// test_cases_scala.stg:29
/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import java.io._

// test_cases_scala.stg:38
<arrsTypeAssignments:{tas|<tas>}; separator="\n">

>>





/* Encode Decode start*/





Codec_Encode(sModName, sFuncName, sVal) ::= <<
// test_cases_scala.stg:54
// Encode value
<sFuncName>(<sVal>, bitStrm, true) match
    case Left(_) => return Left(1)
    case Right(_) => ()
>>

Codec_Decode(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
// test_cases_scala.stg:62
BitStream_AttachBuffer(bitStrm, bitStrm.buf) // TODO: reset curBit, curByte instead?
// Decode value
<sFuncName>(bitStrm) match
    case Left(_) => return Left(2)
    case Right(pVal) => decodedPDU = pVal 
>>
    
Codec_Decode_XER(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
// test_cases_scala.stg:71
ByteStream_AttachBuffer(bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING)
// Decode value
<sFuncName>(bitStrm) match
    case Left(_) => return Left(2)
    case Right(pVal) => decodedPDU = pVal 
>>

Codec_validate_output(sModName, sFuncName, sAmber) ::= <<
// test_cases_scala.stg:80
// validate decoded data
<sFuncName>(decodedPDU) match
    case Left(_) => return Left(3)
    case Right(_) => ()
>>

Codec_compare_input_with_output(sModName, sFuncName, sVal, sAmber) ::= <<
// test_cases_scala.stg:88
if !<sFuncName>(<sVal>, decodedPDU) then
    return Left(4)
>>

Codec_write_CharstreamToFile() ::= <<
// test_cases_scala.stg:94
<Codec_write_bitstreamToFile()>
>>

Codec_write_bitstreamToFile() ::= <<
// test_cases_scala.stg:99
val file = new File(filename)
val bw = new FileOutputStream(file)
bw.write(bitStrm.buf)
bw.close()
>>

JoinItems(sPart, soNestedPart) ::= <<
// test_cases_scala.stg:107
<sPart>
<if(soNestedPart)>
<soNestedPart>
<endif>
>>


Codec_declare_EncInDecOut_variable(sPrmName, sType, sPrmValue) ::= <<
// test_cases_scala.stg:116
<sType> enc_<sPrmName> = <sPrmValue>;
<sType> dec_<sPrmName>;
>>

Codec_declare_DecIn_variable(sPrmName, sType) ::= "<sType> dec_<sPrmName>; /* test_cases_scala.stg:122 */"


PrintCodec_spec(sFuncName, sModName, sTasName, sStar, sVal) ::= <<
// test_cases_scala.stg:125
>>

PrintCodec_body(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
// test_cases_scala.stg:129
def <sFuncName>(<sVal>: <sTasName>, filename: String): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    var decodedPDU: <sTasName> = <sTasName>_Initialize() // TODO: does this always work?

    val bitStrm = BitStream_Init(<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING.toInt) // TODO: what to do with too large Longs?
    <sNestedStatements>
    ret
}
>>

PrintCodec_body_XER(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
// test_cases_scala.stg:142
flag <sFuncName>(const <sTasName><sStar> <sVal>, int* pErrCode, const char* filename)
{
    static <sTasName> decodedPDU;
    static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; /* +1 for zerosized types */
    ByteStream bitStrm;
    flag ret = TRUE;

    ByteStream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
    <sNestedStatements>
    return ret;
}
>>






/* Encode Decode End*/

PrintMain(sTestSuiteFilename) ::= <<
// test_cases_scala.stg:164
package asn1src

def printf_tests_failed(testCount: Int, failedCount: Int): Unit = 
{
    println(s"[test failed] $failedCount out of $testCount failed.")
}

def printf_tests_passed(testCount: Int): Unit =
{
    println(s"[test success] All test cases ($testCount) run successfully.")
}

def printf_null(): Unit =
{
}

def printf_null_char(s: String): Unit =
{
    
}

def printf_message(message: String): Unit =
{
    println(s"$message")
}

def print_test_case_success(message: String, duration: Long): Unit =
{
    println(s"test case '$message' succeeded, duration was \t\t\t\t$duration ms")
}

@main def main(): Int = 
{
    val output = TestOutput(
        report_tests_failed = printf_tests_failed,
        report_all_tests_passed = printf_tests_passed,
        report_suite_begin = printf_null,
        report_suite_end = printf_null,
        report_case_begin = printf_null_char,
        report_case_end = printf_null,
        report_failure_begin = printf_null,
        report_failure_end = printf_null,
        report_failure_message = printf_message,
        report_test_case_success = print_test_case_success
    )

    asn1scc_run_generated_testsuite(output)
}

>>





PrintSuite_call_codec_generate_dat_file(sModName, sTasName, sAmber, sEnc, sStreamName) ::= <<
// test_cases_scala.stg:221
	if (result) {
		static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; /* +1 for zerosized types */
		<sStreamName>Stream bitStrm;
		FILE* fp;

  		<sStreamName>Stream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);

		result = <sTasName>_<sEnc>Encode(<sAmber>tmp, &bitStrm, &errCode, TRUE);
		fp = fopen("asn1scc_<sEnc>.dat","wb");

		if (fp==NULL) 
		{
			printf("fopen failed !!!\n");
			return 2;
		}

	
		fwrite(encBuff,1,(size_t)<sStreamName>Stream_GetLength(&bitStrm),fp);
		fclose(fp);
	};
>>


PrintATCRunnerDefinition() ::= <<
// test_cases_scala.stg:246
package asn1src

case class TestOutput (
    report_tests_failed: (Int, Int) => Unit,
    report_all_tests_passed: Int => Unit,

    report_suite_begin: () => Unit,
    report_suite_end: () => Unit,

    report_case_begin: String => Unit,
    report_case_end: () => Unit,

    report_failure_begin: () => Unit,
    report_failure_end: () => Unit,
    report_failure_message: String => Unit,
    report_test_case_success: (String, Long) => Unit,
)

>>

PrintATCRunner(sTestSuiteFilename, arrsIncludedModules, arrsVars, arrsTestFunctions, arrsUsedPackages, arrsInitCalls, bGenerateDatFile) ::= <<
// test_cases_scala.stg:268
/*  Code automatically generated by asn1scc tool (stg macro : PrintATCRunner) */
package asn1src

import asn1scala._

def asn1scc_run_generated_testsuite(output: TestOutput): Int =
{
    var totalErrors: Int = 0
    <arrsVars; separator="\n">


    output.report_suite_begin()

    // test_cases_scala.stg:282
    <arrsTestFunctions;separator="\n\n">

    output.report_suite_end()

    if totalErrors > 0 then
        output.report_tests_failed(<arrsTestFunctions.Length>, totalErrors)
        return 1
    else
        output.report_all_tests_passed(<arrsTestFunctions.Length>)
        return 0
    
}

>>



invokeTestCaseAsFunc(sFuncName) ::= <<
// test_cases_scala.stg:301
totalErrors += <sFuncName>(output)
>>


emitTestCaseAsFunc_h(sFuncName) ::= <<
>>

emitTestCaseAsFunc_dummy_init(sTypeName, sFuncName, sDummyVarname) ::= <<
// test_cases_scala.stg:310
var <sDummyVarname>: <sTypeName> = <sFuncName>()
>>

emitTestCaseAsFunc_dummy_init_function(sTypeName, sFuncName, sDummyVarname) ::= <<
// test_cases_scala.stg:315
var <sDummyVarname>: <sTypeName> = <sFuncName>()
>>

emitTestCaseAsFunc(sFuncName, arrsVars, sModName, sTasName, sAmber, sEnc, bValueAssignment, sInitializeTcData, bStatic, sGenerateDatFile, arrsDummyInitStatementsNeededForStatementCoverage, sInitAmber) ::= <<
// test_cases_scala.stg:320
def <sFuncName>(output: TestOutput): Int = 
{
    var totalErrors: Int = 0
    var result: Either[ErrorCode, Int] = Left(NOT_INITIALIZED_ERR_CODE)
    <arrsVars; separator="\n">

    output.report_case_begin("<sFuncName>")

    var tc_data: <sTasName> = <sTasName>_Initialize() // TODO: does this always work?
    <sInitializeTcData>

    val start = System.currentTimeMillis()
    result = <sTasName>_<sEnc>enc_dec(tc_data, "<sFuncName>")
    val stop = System.currentTimeMillis() 
    result match
        case Right(_) => 
            output.report_test_case_success("<sTasName>/<sFuncName>", stop - start)
        case Left(errorCode) =>
            output.report_failure_begin()                
            errorCode match
                case 1 =>
                    output.report_failure_message("Test case <sFuncName> failed in encoding.")
                case 2 =>
                    output.report_failure_message("Test case '<sFuncName>' failed in decoding.")
                case 3 =>
                    output.report_failure_message("Test case '<sFuncName>' failed in the validation of the decoded message.")
                case 4 =>
                    output.report_failure_message("Test case '<sFuncName>' failed. Encoded and decoded messages are different.")
                case _ =>
                    output.report_failure_message("Unexpected error code in test case '<sFuncName>'.")
            output.report_failure_message("========================================")
            totalErrors = totalErrors + 1    
            output.report_failure_end()
  
    <sGenerateDatFile>

    output.report_case_end()
    totalErrors
}
>>


printTestCaseFileDef(sThisFile, arrsIncludedModules, arrsTestFunctionDefs) ::= <<
// test_cases_scala.stg:370
/*
Code automatically generated by asn1scc tool
*/
package asn1src

>>

    
printTestCaseFileBody(sThisFile, arrsIncludedModules, arrsTestFunctionBodies) ::= <<
// test_cases_scala.stg:380
/*  Code automatically generated by asn1scc tool (stg macro : printTestCaseFileBody) */
package asn1src

import asn1scala._

// test_cases_scala.stg:386
<arrsTestFunctionBodies;separator="\n\n">

>>


