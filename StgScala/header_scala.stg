group scala_header;

rtlModuleName() ::= ""

indentation(sStatement) ::=<<
    <sStatement>
>>

PrintSpecificationFile(sFileNameWithNoExtUpperCase, sPackageName, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrototypes, arrsUtilityDefines, bHasEncodings, bXer) ::= <<
/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang._
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._

<arrsTypeAssignments:{tas|<tas>}; separator="\n">

<arrsValueAssignments:{vas|<vas>}; separator="\n">

<arrsPrototypes:{proto|<proto>}; separator="\n">
>>

Define_TAS(sTypeDefinition, arrsProcs) ::= <<
<sTypeDefinition>

<arrsProcs; separator="\n\n">
>>

PrintValueAssignment(sName, sTypeDecl, sValue) ::= <<
// @inline @cCode.inline val <sName>: <sTypeDecl> = <sValue> // defined in body
>>

/*
Scala TYPES
*/

Declare_Integer() ::="Long"
Declare_PosInteger() ::="ULong"
Declare_IntegerNoRTL() ::="LongNoRTL"
Declare_PosIntegerNoRTL() ::="ULongNoRTL"

Declare_Boolean() ::= "Boolean"
Declare_Real() ::= "Double"

Declare_Int8() ::="Byte"
Declare_UInt8() ::="UByte"
Declare_Int16() ::="Short"
Declare_UInt16() ::="UShort"
Declare_Int32() ::="Int"
Declare_UInt32() ::="UInt"
Declare_Int64() ::="Long"
Declare_UInt64() ::="ULong"

Declare_Real32() ::= "Float"
Declare_Real64() ::= "Double"

Declare_BooleanNoRTL() ::= "BooleanNoRTL"
Declare_RealNoRTL() ::= "RealNoRTL"


Declare_Null() ::= "NullType"
Declare_NullNoRTL() ::= "NullType"
Declare_ObjectIdentifier() ::= "Asn1ObjectIdentifier"
Declare_ObjectIdentifierNoRTL() ::= "Asn1ObjectIdentifier"

Declare_Asn1LocalTime                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTime                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZone     	()::= "Asn1TimeWithTimeZone"
Declare_Asn1Date                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTime            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTime              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZone	()::= "Asn1DateTimeWithTimeZone"

Declare_Asn1LocalTimeNoRTL                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTimeNoRTL                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZoneNoRTL     	()::= "Asn1TimeWithTimeZone"
Declare_Asn1DateNoRTL                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTimeNoRTL            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTimeNoRTL              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZoneNoRTL	()::= "Asn1DateTimeWithTimeZone"


Define_SubType(sTypeDefinitionName, soParentTypePackage, sParentType, soNewRange, soExtraDefs, arrsAnnots) ::= <<
<arrsAnnots:{ann|@<ann>}; separator=" ">
type <sTypeDefinitionName> = <sParentType>
<soExtraDefs>
>>





/******************************************************************************************************************************/
/***********************************       NEW TYPE DEFINITIONS    ************************************************************/
/******************************************************************************************************************************/

/***********************************       ENUMERATED    ************************************************************/

Define_new_enumerated_item(td/*:FE_EnumeratedTypeDefinition*/, sName, nValue) ::= <<
case object <sName> extends <td.typeName>:
    override def i: Int = <nValue>
>>

Define_new_enumerated_item_macro(td/*:FE_EnumeratedTypeDefinition*/, sAsn1Name, sCName) ::= <<
// type <sCName> = <td.typeName>.<sAsn1Name>
>>

Define_new_enumerated(td/*:FE_EnumeratedTypeDefinition*/, arrsEnumNames, arrsEnumNamesAndValues, nIndexMax, arrsResolvingMacros) ::= <<
sealed trait <td.typeName>:
    def i: Int
object <td.typeName>:
    <arrsEnumNamesAndValues:{it|<it>}; separator="\n">

// please use the following macros to avoid breaking code.
<arrsResolvingMacros; separator="\n">
>>



Define_subType_enumerated(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>
>>

Define_new_enumerated_private(td/*:FE_EnumeratedTypeDefinition*/, arrsValidEnumNames, arrsEnumNames) ::= <<
>>

Define_subType_enumerated_private(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, arrsValidEnumNames, arrsEnumNames) ::= <<
>>

/***********************************       STRING    ************************************************************/

Define_new_ia5string(td/*:FE_StringTypeDefinition*/, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
type <td.typeName> = Vector[UByte]
>>

Define_subType_ia5string(td/*:FE_StringTypeDefinition*/, prTd/*:FE_StringTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>
>>

/***********************************       OCTET STRING    ************************************************************/

Define_new_octet_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, arrsInvariants) ::= <<
<if(!bFixedSize)>
/*nCount equals to Number of bytes in the array. Max value is : <nMax> (unsure - TODO read asn1 standard)*/

<endif>
case class <td.typeName>(<if(!bFixedSize)>nCount: Long, <endif>arr: Vector[UByte])
{
    <arrsInvariants; separator="\n">
}
>>

Define_subType_octet_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName>
>>

/***********************************       BIT STRING    ************************************************************/

Define_new_bit_string_named_bit(td/*:FE_SizeableTypeDefinition*/, sTargetLangBitName, sHexValue, sComment) ::= <<
#define <td.typeName>_<sTargetLangBitName> 0x<sHexValue>  /*<sComment>*/
>>

Define_new_bit_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, nMaxOctets, arrsNamedBits, arrsInvariants) ::= <<
<arrsNamedBits:{it|<it>}; separator="\n">

<if(!bFixedSize)>
/*nCount equals to Number of bits in the array. Max value is : <nMax> */

<endif>
case class <td.typeName>(<if(!bFixedSize)>nCount: Long, <endif>arr: Vector[UByte])
{
    <arrsInvariants; separator="\n">
}
>>

Define_subType_bit_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName>
>>

/***********************************       SEQUENCE OF    ************************************************************/


Define_new_sequence_of(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, sChildType, soChildDefinition, arrsSizeClassDefinition, arrsSizeObjDefinition, arrsInvariants) ::= <<

<soChildDefinition>

case class <td.typeName> (<if(!bFixedSize)>nCount: Int, <endif>arr: Vector[<sChildType>])
{
    <arrsInvariants; separator="\n">

    <arrsSizeClassDefinition; separator="\n\n">
}
object <td.typeName> {
    <arrsSizeObjDefinition; separator="\n\n">
}
>>

Define_subType_sequence_of(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize, soChildDefinition) ::= <<

<soChildDefinition>

typedef <prTd.typeName> <td.typeName>
>>


/***********************************       SEQUENCE     ************************************************************/

Define_new_sequence_child_bit(sName) ::= "<sName>: Boolean"

Define_new_sequence_child(sName, sType, bIsOptional) ::= <<
<if (bIsOptional)>
<sName>: OptionMut[<sType>]
<else>
<sName>: <sType>
<endif>
>>

Define_new_sequence_save_pos_child(td/*:FE_SequenceTypeDefinition*/, sName, nMaxBytesInACN) ::= "BitStream <sName>;"

Define_new_sequence(td/*:FE_SequenceTypeDefinition*/, arrsChildren, arrsOptionalChildren, arrsChildrenDefinitions, arrsNullFieldsSavePos, arrsSizeDefinition, arrsInvariants) ::= <<
/*-- <td.typeName> --------------------------------------------*/
<arrsChildrenDefinitions; separator= "\n">
<if (arrsNullFieldsSavePos)>
case class <td.extension_function_positions> (
    <arrsNullFieldsSavePos; separator="\n">
) {
    <arrsInvariants; separator="\n">

    <arrsSizeDefinition; separator="\n\n">
}

<endif>


case class <td.typeName> (
    <arrsChildren:{ch|<ch>}; separator=", \n">
) {
    <arrsInvariants; separator="\n">

    <arrsSizeDefinition; separator="\n\n">
}

>>

Define_subType_sequence(td/*:FE_SequenceTypeDefinition*/, prTd/*:FE_SequenceTypeDefinition*/, soParentTypePackage, arrsOptionalChildren, arrsExtraDefs) ::= <<
type <td.typeName> = <prTd.typeName>

object <td.typeName> {
    <arrsExtraDefs; separator="\n">
}

<if (arrsNullFieldsSavePos)>
type <td.extension_function_positions> = <prTd.extension_function_positions>
<endif>
>>

/***********************************       CHOICE    ************************************************************/


Define_new_choice_child(sName, sType, sPresent) ::=<<
<sName>: <sType>
>>

Define_new_choice(td/*:FE_ChoiceTypeDefinition*/, sChoiceIDForNone, sFirstChildNamePresent, arrsChildren, arrsPresent, arrsCombined, nIndexMax, arrsChildrenDefinitions, arrsSizeDefinition) ::= <<
/*-- <td.typeName> --------------------------------------------*/
<arrsChildrenDefinitions; separator= "\n">

enum <td.typeName>:
    <arrsCombined:{ch|case <ch>}; separator="\n">

    <arrsSizeDefinition; separator="\n\n">
>>

Define_subType_choice(td/*:FE_ChoiceTypeDefinition*/, prTd/*:FE_ChoiceTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>
>>

Define_SubType_int_range(soParentTypePackage, sParentType, noMin, noMax) ::= <<
>>
