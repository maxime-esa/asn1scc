/*
* Copyright (c) 2008-2012 Semantix and (c) 2012-2015 Neuropublic
*
* This file is part of the ASN1SCC tool.
*
* Licensed under the terms of GNU General Public Licence as published by
* the Free Software Foundation.
*
*  For more informations see License.txt file
*/

group c_source;


getStringSize(p) ::= "strlen(<p>)"

getSizeableSize(p) ::= "<p>nCount"

Print_AlphabetCheckFunc_str(p) ::= "<p>[i]"




main(sFileNameWithoutExtension, arrsUnnamedVariables, arrsValueAssignments, arrsTypeAssignments, soMappingFunctionsModule) ::= <<
/*
Code automatically generated by asn1scc tool
*/
#include \<limits.h>
#include \<string.h>
#include \<math.h>
#include "<sFileNameWithoutExtension>.h"
<if(soMappingFunctionsModule)>
#include "<soMappingFunctionsModule>.h"

<endif>

<arrsUnnamedVariables: {uv|<uv>}; separator="\n">

<arrsValueAssignments: {uv|<uv>}; separator="\n">

<arrsTypeAssignments: {uv|<uv>}; separator="\n\n">

>>

gcc_main(sFileNameWithoutExtension, arrsValueAssignments) ::= <<
#include "<sFileNameWithoutExtension>.h"

<arrsValueAssignments: {uv|<uv>}; separator="\n">
>>

PrintUnnamedVariable(sTypeDecl, sName, sValue) ::= "const <sTypeDecl> <sName> = <sValue>;"

PrintValueAssignment(sTypeDecl, sName, sValue) ::= "const <sTypeDecl> <sName> = <sValue>;"





/*
*****************************************************************************************
 I N I T I A L I Z E      F U N C T I O N S
*****************************************************************************************
*/

PrintInitialize(sTasName, sStar, sContent, bIsString) ::= <<
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void <sTasName>_Initialize(<sTasName><sStar> pVal)
{
<if(!bIsString)>
    *pVal = (<sTasName>) <sContent>;
<else>
    static <sTasName> ret = 
        <sContent>;
    strcpy(pVal, ret);
<endif>

}
#endif
>>


/*
*****************************************************************************************
 C H E C K   C O N S T R A I N T S      F U N C T I O N S
*****************************************************************************************
*/

PrintIsConstraintValid(sTasName, sStar, arrsLocalVariables, sContent, arrsAlphaCheckFunctions) ::= <<
<arrsAlphaCheckFunctions; separator="\n"> 
flag <sTasName>_IsConstraintValid(const <sTasName><sStar> pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	<arrsLocalVariables; separator="\n">
	*pErrCode=0;

	(void)pVal;

	<sContent>

	return ret;
}
>>



SingleValContraint(p, v) ::= "(<p> == <v>)"

SingleValContraint_bitString_fixedSize(p1, p2, nFixedSize) ::= <<
((memcmp(<p1>arr, <p2>.arr, <nFixedSize>/8) == 0) && ((<nFixedSize> % 8) >0 ? (<p1>arr[<nFixedSize>/8]\>>(8-<nFixedSize> % 8) == <p2>.arr[<nFixedSize>/8]\>>(8-<nFixedSize> % 8) ) : TRUE))
>>

SingleValContraint_bitString_varSize(p1, p2) ::= <<
(((<p1>nCount == <p2>.nCount) && (memcmp(<p1>arr, <p2>.arr, <p1>nCount/8) == 0)) && (<p1>nCount % 8 > 0 ? (<p1>arr[<p1>nCount/8] \>> (8-<p1>nCount % 8) == <p2>.arr[<p1>nCount/8]\>>(8-<p1>nCount % 8) ) : TRUE))
>>


SingleValContraint_octetString_fixedSize(p1, p2, nFixedSize) ::= <<
(memcmp(<p1>arr, <p2>.arr, <nFixedSize>) ==0)
>>

SingleValContraint_octetString_varSize(p1, p2) ::= <<
((<p1>nCount == <p2>.nCount) && (memcmp(<p1>arr, <p2>.arr, <p1>nCount) ==0))
>>


stringContainsChar(sStrVal, p) ::= "strchr(<sStrVal>, <p>)"

RangeContraint(p, v1, v2, bMin, bMax) ::= "(<v1> \<<if(bMin)>=<endif> <p> && <p> \<<if(bMax)>=<endif> <v2>)"

RangeContraint_val_MAX(p, v, bMin) ::= "(<p> ><if(bMin)>=<endif> <v>)"

RangeContraint_MIN_val(p, v, bMax) ::= "(<p> \<<if(bMax)>=<endif> <v>)"


AND_Constraint(sCon1, sCon2) ::= "(<sCon1> && <sCon2>)"

OR_Constraint(sCon1, sCon2) ::= "(<sCon1> || <sCon2>)"

AllExceptConstraint(sCon)  ::= "(!<sCon>)"

ExceptConstraint(sCon1,sCon2) ::= "(<sCon1> &&  !<sCon2>)"

callAlphaFunc(sFuncName, p) ::= "<sFuncName>_CharsAreValid(<p>)"

PrintMultipleConstraints(arrsConstraints) ::= "<arrsConstraints; separator=\" && \">"


Emit_local_variable_SQF_Index(nI)::="int i<nI>=0;"


Print_AlphabetCheckFunc(sName, arrsAlphaConBody) ::= <<
flag <sName>_CharsAreValid(const char* pVal) 
{
    flag ret=TRUE;
    int i=0;

    while ((pVal[i] != '\0') && ret) {
        ret = ret && (<arrsAlphaConBody; separator=" && ">);
        i = i + 1;
    }
    return ret;
}
>>


Emit_type(arrsConstraints, sErrCodeName) ::= <<
ret = <arrsConstraints; separator=" && ">;
*pErrCode = ret ? 0 : <sErrCodeName>;
>>


Emit_Reference1(p, sTasName) ::= "ret = <sTasName>_IsConstraintValid(<p>, pErrCode);"

Emit_Reference2(p, sModName,sTasName) ::= "<Emit_Reference1(p=p, sTasName = sTasName)>"




/* SEQUENCE start*/
Emit_sequence_optional_component(sParentPath, sName, sChildBody) ::=<<
if (<sParentPath>exist.<sName>==1) {
    <sChildBody>
}
>>

Emit_sequence_check_component_is_always_present_or_absent(sParentPath, sName, nPresOrAbs, sErrCode) ::= <<
ret= <sParentPath>exist.<sName>==<nPresOrAbs>;
*pErrCode = ret ? 0 : <sErrCode>;
>>

JoinItems(sPart, sNestedPart) ::= <<
<sPart>
<if(sNestedPart)>
if (ret) {
    <sNestedPart>
}
<endif>
>>

/* SEQUENCE end*/


/* CHOICE start*/
Emit_choice_child(sChPresent, sChildBody) ::= <<
case <sChPresent> :
    <sChildBody>
    break;
>>

Emit_choice(p, arrsChildren, sChoiceErrName) ::= <<
switch (<p>kind) {
    <arrsChildren; separator="\n">
    default:
	    *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;   //COVERAGE_IGNORE
	    ret = FALSE;                    //COVERAGE_IGNORE
}
>>

/* CHOICE end*/


Emit_fixedSize_constraint() ::= "ret = TRUE; *pErrCode = 0;"



Emit_sequence_of(sI, sPath, nMax, sSizeConstraint, sChildBody, bFixed) ::= <<
<sSizeConstraint>
<sI> = 0;
while (ret && (<sI>\< <if(bFixed)><nMax><else><sPath>nCount<endif>)) {
    <sChildBody>
    <sI> = <sI>+1;
}
>>







/*
*****************************************************************************************
 E Q U A L      F U N C T I O N S
*****************************************************************************************
*/
PrintEqual(sName, sStar, arrsLocalVariables, sContent) ::= <<
flag <sName>_Equal(const <sName><sStar> pVal1, const <sName><sStar> pVal2)
{
	flag ret=TRUE;
	<arrsLocalVariables:{lv|<lv>}; separator="\n">
	
	<sContent>

	return ret;
}
>>

isEqual_Integer(p1, p2) ::= "ret = (<p1> == <p2>);"

isEqual_Enumerated(p1, p2) ::= "<isEqual_Integer(p1=p1,p2=p2)>"


isEqual_Boolean(p1, p2) ::= "ret = ( (<p1> && <p2>) || (!<p1> && !<p2>));"

isEqual_Real(p1, p2) ::= <<
ret =  <p1> == <p2> ? TRUE : (<p1> == 0.0 ? <p2> ==0.0 : (fabs((<p1> - <p2>) / <p1>) \< 0.00001));
>>

isEqual_IA5String(p1, p2) ::= "ret = (strcmp(<p1>, <p2>) ==0);"

isEqual_NumericString(p1, p2) ::= "<isEqual_IA5String(p1=p1, p2=p2)>"
isEqual_NullType() ::= "ret = TRUE;"

isEqual_BitString(p1,p2,bIsFixedSize, nFixedSize) ::= <<
<if(!bIsFixedSize)>
ret = ((<p1>nCount == <p2>nCount) && (memcmp(<p1>arr, <p2>arr, <p1>nCount/8) == 0));
ret = ret && (<p1>nCount % 8 > 0 ? (<p1>arr[<p1>nCount/8] \>> (8-<p1>nCount % 8) == <p2>arr[<p1>nCount/8]\>>(8-<p1>nCount % 8) ) : TRUE);

<else>
ret = memcmp(<p1>arr, <p2>arr, <nFixedSize>/8) == 0;
ret = ret && ((<nFixedSize> % 8) >0 ? (<p1>arr[<nFixedSize>/8]\>>(8-<nFixedSize> % 8) == <p2>arr[<nFixedSize>/8]\>>(8-<nFixedSize> % 8) ) : TRUE);

<endif>
>>

isEqual_OctetString(p1,p2,bIsFixedSize, nFixedSize) ::= <<
<if(!bIsFixedSize)>
ret = ((<p1>nCount == <p2>nCount) && (memcmp(<p1>arr, <p2>arr, <p1>nCount) ==0));

<else>
ret = (memcmp(<p1>arr, <p2>arr, <nFixedSize>) ==0);

<endif>	
>>

isEqual_Choice_Child(sCid, sInnerType) ::= <<
case <sCid>:
	<sInnerType>
	break;
>>

isEqual_Choice(p1,p2, arrsChildren) ::= <<
ret = (<p1>kind == <p2>kind);
if (ret) {
	switch(<p1>kind) 
	{
	<arrsChildren: {ch|<ch>}; separator="\n">
	default:
		ret = FALSE;    //COVERAGE_IGNORE
	}
}
>>

isEqual_Sequence_child(p1, p2, bIsOptional, sChName, sInnerType) ::= <<
<if(bIsOptional)>
ret = (<p1>exist.<sChName> == <p2>exist.<sChName>);
if (ret && <p1>exist.<sChName>) {
	<sInnerType>
}
<else>
<sInnerType>
<endif>
>>


isEqual_SequenceOf(p1,p2, i, bIsFixedSize, nFixedSize, sInnerType) ::= <<
<if(!bIsFixedSize)>
ret = (<p1>nCount == <p2>nCount);
<endif>

for(<i> = 0; ret && <i>\<<if(!bIsFixedSize)><p1>nCount<else><nFixedSize><endif>; <i>++) 
{
	<sInnerType>
}
>>


isEqual_ReferenceType(sPtr1, sPtr2, sName) ::= <<
ret = <sName>_Equal(<sPtr1>, <sPtr2>);
>>



/*******************************************************/
/*   U P E R                                           */
/*******************************************************/

Declare_EnumIndex() ::= "asn1SccSint enumIndex;"
Declare_Length()    ::= "asn1SccSint nCount;"
Declare_ChoiceIndex() ::= "asn1SccSint nChoiceIndex;"
Declare_SequenceBitMask(sName, nSize) ::= "unsigned char <sName>[<nSize>];"

PrintUper_encode(sName, sStar, arrsLocalVariables, sContent) ::= <<
flag <sName>_Encode(const <sName><sStar> pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	<arrsLocalVariables:{lv|<lv>}; separator="\n">
    
	ret = bCheckConstraints ? <sName>_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    <sContent>
    }

	return ret;
}
>>

PrintUper_decode(sName, sStar, arrsLocalVariables, sContent) ::= <<
flag <sName>_Decode(<sName><sStar> pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	<arrsLocalVariables:{lv|<lv>}; separator="\n">

	<sContent>

	return ret;
}
>>



InternalItem_oct_str_encode(p, i, sErrInsufficientData) ::=<<
BitStream_AppendByte0(pBitStrm, <p>arr[<i>]);
>>

InternalItem_oct_str_decode(p, i, sErrInsufficientData) ::=<<
ret = BitStream_ReadByte(pBitStrm, &<p>arr[<i>]); 
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
>>

PrintAlphabet2(arrnCharSet) ::= <<
static byte allowedCharSet[] = {<arrnCharSet:{ch|0x<ch;format="X2">}; wrap, anchor, separator=",">}; 
>>


InternalItem_string_with_alpha_encode(p, i, nLastItemIndex, arrnAlphabetAsciiCodes, nAlphabetLength) ::=<<
<PrintAlphabet2(arrnAlphabetAsciiCodes)>
int charIndex = GetCharIndex(<p>[<i>], allowedCharSet, <nAlphabetLength>);
BitStream_EncodeConstraintWholeNumber(pBitStrm, charIndex, 0, <nLastItemIndex>);
>>
InternalItem_string_with_alpha_decode(p, i, nLastItemIndex, arrnAlphabetAsciiCodes, nAlphabetLength) ::=<<
<PrintAlphabet2(arrnAlphabetAsciiCodes)>
asn1SccSint charIndex = 0;
ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &charIndex, 0, <nLastItemIndex>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
<p>[<i>] = ret ? allowedCharSet[charIndex] : '\0' ;
>>

InternalItem_string_no_alpha_encode(p, i) ::=<<
BitStream_EncodeConstraintWholeNumber(pBitStrm, <p>[<i>], 0, 127);
>>

InternalItem_string_no_alpha_decode(p, i) ::=<<
asn1SccSint charValue=0;
ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &charValue, 0, 127);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
<p>[<i>] = (char)charValue;
>>


/* INTETEGER START*/


/*case: A:: = INTEGER (-5..20) */
IntFullyConstraint_encode(p, nMin, nMax, nBits, sErrCode) ::= "BitStream_EncodeConstraintWholeNumber(pBitStrm, <p>, <nMin>, <nMax>);"
IntFullyConstraint_decode(p, nMin, nMax, nBits, sErrCode) ::= <<
ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, <p>, <nMin>, <nMax>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
>>

/*case: Positive fully constraint A:: = INTEGER (5..20) */
IntFullyConstraintPos_encode(p, nMin, nMax, nBits, sErrCode) ::= "BitStream_EncodeConstraintPosWholeNumber(pBitStrm, <p>, <nMin>, <nMax>);"
IntFullyConstraintPos_decode(p, nMin, nMax, nBits, sErrCode) ::= <<
ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, <p>, <nMin>, <nMax>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
>>


/*case: A :: = INTEGER */
IntUnconstraint_encode(p, sErrCode) ::= "BitStream_EncodeUnConstraintWholeNumber(pBitStrm, <p>);"
IntUnconstraint_decode(p, sErrCode) ::= <<
ret = BitStream_DecodeUnConstraintWholeNumber(pBitStrm, <p>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
>>



/*case: A:: = INTEGER (-5..MAX) */
IntSemiConstraint_encode(p, nMin, sErrCode) ::= "BitStream_EncodeSemiConstraintWholeNumber(pBitStrm, <p>, <nMin>);"
IntSemiConstraint_decode(p, nMin, sErrCode) ::= <<
ret = BitStream_DecodeSemiConstraintWholeNumber(pBitStrm, <p>, <nMin>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
>>


/*case: A:: = INTEGER (5..MAX) */
IntSemiConstraintPos_encode(p, nMin, sErrCode) ::= "BitStream_EncodeSemiConstraintPosWholeNumber(pBitStrm, <p>, <nMin>);"
IntSemiConstraintPos_decode(p, nMin, sErrCode) ::= <<
ret = BitStream_DecodeSemiConstraintPosWholeNumber(pBitStrm, <p>, <nMin>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
>>


/*case: A:: = INTEGER (5..5) */
IntNoneRequired_encode(p, nConst, sErrCode) ::= "/* No need to encode value since it will always be <nConst> */"
IntNoneRequired_decode(p, nConst, sErrCode) ::= "<p>=<nConst>; ret = TRUE; *pErrCode = 0;"


/*case: A:: = INTEGER (5..40,...) */
IntRootExt_encode(p, nMin, sRootBaseConstraint, sIntBody, sErrCode) ::=<<
BitStream_AppendBitZero(pBitStrm); /* write extension bit*/
<sIntBody>
>>


IntRootExt_decode(p, nMin, sRootBaseConstraint, sIntBody, sErrCode) ::=<<
{
	flag extBit=0;
	/* read extension bit*/
	ret = BitStream_ReadBit(pBitStrm, &extBit);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    if (ret) {
	    if (extBit==0) { /* ext bit is zero ==> value is expecteted with root range*/
		    <sIntBody>
	    } else {
		    <IntUnconstraint_decode(p=p, sErrCode = sErrCode)>
	    }
    }
}
>>


/*case: A:: = INTEGER (5..40,..., 60..70) */
IntRootExt2_encode(p, nMin, sRootBaseConstraint, sIntBody, sErrCode) ::=<<
if (<sRootBaseConstraint>) {
    BitStream_AppendBitZero(pBitStrm); /* write extension bit, value within root range, so ext bit is zero */
    <sIntBody>
} else {
    /* value is not within root range, so ext bit is one and value is encoded as uncostraint */
    BitStream_AppendBitOne(pBitStrm);
    <IntUnconstraint_encode(p=p, sErrCode=sErrCode)>
};
>>

IntRootExt2_decode(p, nMin, sRootBaseConstraint, sIntBody, sErrCode) ::= "<IntRootExt_decode(p=p, nMin=nMin, sRootBaseConstraint = sRootBaseConstraint, sIntBody = sIntBody, sErrCode=sErrCode)>"


/* INTETEGER END*/



Null_encode(p) ::= <<
/* NULL type */
>>

Null_decode(p) ::= <<
/* NULL type */
>>

Boolean_encode(p, sErrCode) ::= "BitStream_AppendBit(pBitStrm,<p>);"

Boolean_decode(p, sErrCode) ::= <<
ret = BitStream_ReadBit(pBitStrm, <p>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
>>

Real_encode(p, sErrCode) ::= "BitStream_EncodeReal(pBitStrm, <p>);"
Real_decode(p, sErrCode) ::= <<
BitStream_DecodeReal(pBitStrm, <p>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
>>



uper_Enumerated_item_encode(p, sName, nIndex, nLastItemIndex) ::= <<
case <sName>:   
    BitStream_EncodeConstraintWholeNumber(pBitStrm, <nIndex>, 0, <nLastItemIndex>);
	break;
>>

uper_Enumerated_item_decode(p, sName, nIndex, nLastItemIndex) ::= <<
case <nIndex>: 
    <p> = <sName>;
    break;
>>

uper_Enumerated_encode(p, arrsItem, sErrCode, nLastItemIndex) ::= <<
switch(<p>) 
{
    <arrsItem; separator="\n">
    default:
	    *pErrCode = ERR_INVALID_ENUM_VALUE; //COVERAGE_IGNORE
	    ret = FALSE;            //COVERAGE_IGNORE
}
>>

uper_Enumerated_decode(p, arrsItem, sErrCode, nLastItemIndex) ::= <<
ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, <nLastItemIndex>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
if (ret) {
    switch(enumIndex) 
    {
        <arrsItem; separator="\n">
        default:
	        *pErrCode = ERR_INVALID_ENUM_VALUE;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
    }
}
>>



ReferenceType1_encode(p, sName) ::= "ret = <sName>_Encode(<p>, pBitStrm, pErrCode, FALSE);"
ReferenceType1_decode(p, sName) ::= "ret = <sName>_Decode(<p>, pBitStrm, pErrCode);"

ReferenceType2_encode(p, sModName, sName) ::= "<ReferenceType1_encode(p=p, sName=sName)>"
ReferenceType2_decode(p, sModName, sName) ::= "<ReferenceType1_decode(p=p, sName=sName)>"



uper_Choice_child_encode(p, sChildID, nChildIndex, nLastItemIndex, sChildContent) ::= <<
case <sChildID>:
	BitStream_EncodeConstraintWholeNumber(pBitStrm, <nChildIndex>, 0, <nLastItemIndex>);
	<sChildContent>
	break;
>>
uper_Choice_child_decode(p, sChildID, nChildIndex, nLastItemIndex, sChildContent) ::= <<
case <nChildIndex>:
	<p>kind = <sChildID>;
	<sChildContent>
	break;
>>

uper_Choice_encode(p, arrsChildren, nLastItemIndex, sErrCode) ::= <<
switch(<p>kind) 
{
<arrsChildren: {ch|<ch>}; separator="\n">
default:
    *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;         //COVERAGE_IGNORE
    ret = FALSE;                    //COVERAGE_IGNORE
}
>>

uper_Choice_decode(p, arrsChildren, nLastItemIndex, sErrCode) ::= <<
ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, <nLastItemIndex>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
if (ret) {
    switch(nChoiceIndex) 
    {
    <arrsChildren: {ch|<ch>}; separator="\n">
    default:
        *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;     //COVERAGE_IGNORE
        ret = FALSE;                //COVERAGE_IGNORE
    }
}
>>




/* SEQUENCE START */
uper_Sequence_optChild_encode(p, sChName) ::= "BitStream_AppendBit(pBitStrm,<p>exist.<sChName>);"
uper_Sequence_optChild_decode(p, sChName) ::= ""

uper_Sequence_optChild_always_present_encode(p, sChName) ::= "BitStream_AppendBit(pBitStrm,1);"
uper_Sequence_optChild_always_present_decode(p, sChName) ::= ""


uper_Sequence_mandatory_child_encode(sChName, sChildContent) ::= <<
/*Encode <sChName> */
<sChildContent>
>>

uper_Sequence_mandatory_child_decode(sChName, sChildContent) ::= <<
/*Decode <sChName> */
<sChildContent>
>>


uper_Sequence_optional_child_encode(p, sChName, sChildContent, sBitMaskName, nByteIndex, sAndMask) ::= <<
/*Encode <sChName> */
if (<p>exist.<sChName>) {
	<sChildContent>
}
>>

uper_Sequence_optional_child_decode(p, sChName, sChildContent, sBitMaskName, nByteIndex, sAndMask) ::= <<
/*Decode <sChName> */
<p>exist.<sChName> = 0;
if ((<sBitMaskName>[<nByteIndex>] & 0x<sAndMask>) != 0 ) {
	<p>exist.<sChName> = 1;
	<sChildContent>
}
>>


uper_Sequence_default_child_encode(p, sChName, sChildContent, sBitMaskName, nByteIndex, sAndMask, sChildTypeDeclaration, sDefaultValue) ::= <<
<uper_Sequence_optional_child_encode(p=p, sChName=sChName, sChildContent=sChildContent, sBitMaskName=sBitMaskName, nByteIndex=nByteIndex, sAndMask=sAndMask)>
>>


uper_Sequence_default_child_decode(p, sChName, sChildContent, sBitMaskName, nByteIndex, sAndMask, sChildTypeDeclaration, sDefaultValue) ::= <<
/*Decode <sChName> */
{
    static <sChildTypeDeclaration> defValue = <sDefaultValue>;
    <p>exist.<sChName> = 1;
    <p><sChName> = defValue;
    if ((<sBitMaskName>[<nByteIndex>] & 0x<sAndMask>) != 0 ) {
	    <sChildContent>
    }
}
>>


uper_Sequence_encode(sChildren, bHasOptionalChildren, sBitMaskName, nOptionalChildrenLength) ::= <<
<sChildren>
>>


uper_Sequence_decode(sChildren, bHasOptionalChildren, sBitMaskName, nOptionalChildrenLength) ::= <<
<if(bHasOptionalChildren)>
/* Decode Bit Mask for optional and default fields*/
ret = BitStream_ReadBits(pBitStrm, <sBitMaskName>, <nOptionalChildrenLength>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
if (ret) {
    <sChildren>
}

<else>
<sChildren>

<endif>
>>


/* SEQUENCE END */

loopFixedItem (i, fixedSize,  sInternalItem)::= /*nogen*/<<	
for(<i>=0; (<i> \< <fixedSize>) && ret; <i>++) 
{
	<sInternalItem>
}
>>


/* IA5String & Numeric String */
uper_str_FixedSize_encode(p, i, sInternalItem, nFixedSize) ::= <<
<loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize=nFixedSize)>
>>

uper_str_FixedSize_decode(p, i, sInternalItem, nFixedSize) ::= <<
<loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize=nFixedSize)>
<p>[<nFixedSize>] = 0x0;
>>

uper_str_VarSize_encode(p, i, sInternalItem, nSizeMin, nSizeMax, sStrLen) ::= <<
BitStream_EncodeConstraintWholeNumber(pBitStrm, <sStrLen>, <nSizeMin>, <nSizeMax>);
<loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize=sStrLen)>
>>

uper_str_VarSize_decode(p, i, sInternalItem, nSizeMin, nSizeMax, sStrLen ) ::= <<
ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, <nSizeMin>, <nSizeMax>);
<loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize="nCount")>
<p>[nCount] = 0x0;
>>



/* SEQUENCE OF & OCTET STRING*/

oct_sqf_FixedSize_encode(p, i, sInternalItem, nFixedSize) ::= <<
<loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize=nFixedSize)>
>>

oct_sqf_FixedSize_decode(p, i, sInternalItem, nFixedSize) ::= <<
<loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize=nFixedSize)>
>>


oct_sqf_VarSize_encode(p, i, sInternalItem, nSizeMin, nSizeMax, sCount) ::= <<
BitStream_EncodeConstraintWholeNumber(pBitStrm, <sCount>, <nSizeMin>, <nSizeMax>);
<loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize=sCount)>
>>

oct_sqf_VarSize_decode(p, i, sInternalItem, nSizeMin, nSizeMax, sCount) ::= <<
ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, <nSizeMin>, <nSizeMax>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
<sCount> = (long)nCount;
<loopFixedItem(i=i, sInternalItem=sInternalItem, fixedSize=sCount)>
>>



uper_bitString_FixSize_encode(p, nFixedSize) ::= "BitStream_AppendBits(pBitStrm, <p>arr, <nFixedSize>);"
uper_bitString_FixSize_decode(p, nFixedSize) ::= <<
ret = BitStream_ReadBits(pBitStrm, <p>arr, <nFixedSize>);
*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
>>

uper_bitString_VarSize_encode(p, nSizeMin, nSizeMax) ::= <<
BitStream_EncodeConstraintWholeNumber(pBitStrm, <p>nCount, <nSizeMin>, <nSizeMax>);
<uper_bitString_FixSize_encode(p=p, nFixedSize=[p,"nCount"])>
>>

uper_bitString_VarSize_decode(p, nSizeMin, nSizeMax) ::= <<
ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, <nSizeMin>, <nSizeMax>);
<p>nCount = (long)nCount;
<uper_bitString_FixSize_decode(p=p, nFixedSize=[p,"nCount"])>
>>




Fragmentation_sqf_encode(p, bIsBitStringType, nLevel, sInternalItem, sCount, nUperMax, bIsAsciiString, bIsFixedSize) ::= <<
{
	asn1SccSint nCount<nLevel> = <sCount>;
	asn1SccSint curBlockSize<nLevel> = 0;
	asn1SccSint curItem<nLevel> = 0;
	while (nCount<nLevel> >= 0x4000) 
	{
		if (nCount<nLevel> >= 0x10000)
		{
			curBlockSize<nLevel> = 0x10000;
			BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC4, 0, 0xFF); 
		}
		else if (nCount<nLevel> >= 0xC000)
		{
			curBlockSize<nLevel> = 0xC000;
			BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC3, 0, 0xFF); 
		}
		else if (nCount<nLevel> >= 0x8000)
		{
			curBlockSize<nLevel> = 0x8000;
			BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC2, 0, 0xFF); 
		}
		else 
		{
			curBlockSize<nLevel> = 0x4000;
			BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC1, 0, 0xFF); 
		}
	
		<if(bIsBitStringType)>
		BitStream_AppendBits(pBitStrm, &<p>arr[curItem<nLevel>/8], (int)curBlockSize<nLevel>);
		<else>
		for(i<nLevel>=(int)curItem<nLevel>; i<nLevel> \< curBlockSize<nLevel> + curItem<nLevel>; i<nLevel>++)
		{
			<sInternalItem>
		}
		<endif>
		curItem<nLevel> += curBlockSize<nLevel>;
		nCount<nLevel> -= curBlockSize<nLevel>;
	}

	if (nCount<nLevel> \<= 0x7F)
		BitStream_EncodeConstraintWholeNumber(pBitStrm, nCount<nLevel>, 0, 0xFF);
	else
	{
		BitStream_AppendBit(pBitStrm, 1);
		BitStream_EncodeConstraintWholeNumber(pBitStrm, nCount<nLevel>, 0, 0x7FFF);
	}

	<if(bIsBitStringType)>
	BitStream_AppendBits(pBitStrm, &<p>arr[curItem<nLevel>/8], (int)nCount<nLevel>);
	<else>
	for(i<nLevel>=(int)curItem<nLevel>; i<nLevel> \< curItem<nLevel> + nCount<nLevel>; i<nLevel>++)
	{
		<sInternalItem>
	}
	<endif>
}
>>

Fragmentation_sqf_decode(p, bIsBitStringType, nLevel, sInternalItem, sCount, nUperMax, bIsAsciiString, bIsFixedSize) ::= <<
{
	asn1SccSint nCount<nLevel> = 0;
	asn1SccSint curBlockSize<nLevel> = 0;
	asn1SccSint curItem<nLevel> = 0;
    <if(!bIsFixedSize)><sCount> = 0;<endif>
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount<nLevel>, 0, 0xFF);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    if (ret) {
	    while(ret && (nCount<nLevel> & 0xC0)==0xC0) 
	    {
		    if (nCount<nLevel> == 0xC4)
			    curBlockSize<nLevel> = 0x10000;
		    else if (nCount<nLevel> == 0xC3)
			    curBlockSize<nLevel> = 0xC000;
		    else if (nCount<nLevel> == 0xC2)
			    curBlockSize<nLevel> = 0x8000;
		    else if (nCount<nLevel> == 0xC1)
			    curBlockSize<nLevel> = 0x4000;
		    else {
			    *pErrCode = ERR_INCORRECT_PER_STREAM;
			    return FALSE;
		    }
		    if (curItem<nLevel> + curBlockSize<nLevel> > <nUperMax>)
		    {
			    *pErrCode = ERR_INSUFFICIENT_DATA;
			    return FALSE;
		    }

		    <if(bIsBitStringType)>
		    ret = BitStream_ReadBits(pBitStrm, &<p>arr[curItem<nLevel>/8], (int)curBlockSize<nLevel>);
            *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
		    <else>
		    for(i<nLevel>=curItem<nLevel>; ret && (i<nLevel> \< curItem<nLevel> + curBlockSize<nLevel>) ; i<nLevel>++)
		    {
			    <sInternalItem>
		    }
		    <endif>
	
            if (ret) {
		        <if(!bIsAsciiString)>
		        <if(!bIsFixedSize)><sCount> += (long)curBlockSize<nLevel>;<endif>
		        <endif>
		        curItem<nLevel> += curBlockSize<nLevel>;
		        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount<nLevel>, 0, 0xFF);
                *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
            }
	    }
        if (ret) {
	        if ( (nCount<nLevel> & 0x80)>0) 
	        {
		        asn1SccSint len2;
		        nCount<nLevel> \<\<= 8;
		        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &len2, 0, 0xFF);
                *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
                if (ret) {
		            nCount<nLevel> |= len2;
		            nCount<nLevel> &= 0x7FFF;
                }
	        }
            ret = ret && (curItem<nLevel> + nCount<nLevel> \<= <nUperMax>);
            *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
            if (ret) {
	            <if(bIsBitStringType)>
                ret = BitStream_ReadBits(pBitStrm, &<p>arr[curItem<nLevel>/8], (int)nCount<nLevel>);
                *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	            <else>
	            for(i<nLevel>=curItem<nLevel>; ret && (i<nLevel> \< curItem<nLevel> + nCount<nLevel>) ; i<nLevel>++)
	            {
		            <sInternalItem>
	            }
	            <endif>
                if (ret) {
	                <if(!bIsAsciiString)>
	                <if(!bIsFixedSize)><sCount> += (long)nCount<nLevel>;<endif>
	                <endif>
                }
            }
        }
    }
}
>>


PrintDefaultAcnModule(sModName, arrsTypeAssignments, sAssignOperator) ::= <<
<sModName> DEFINITIONS <sAssignOperator> BEGIN
    <arrsTypeAssignments; separator="\n">
END
>>
